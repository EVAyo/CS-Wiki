# 206. 链表反转

---

[92. 反转链表 II — Medium](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

## 📜 题目描述

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:

```
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

## 💡 解题思路

- 对于需要反转的部分，用头插法进行反转
- 对不需要反转的部分，不操作

具体做法：

首先新建 newHead 节点链接到原链表的 head 上，因为若 m=1，需要 newHead 作为中介进行头插，相当于我们手动为这个链表加上了一个头节点。

首先根据方法的参数 m 确定 g 和 p 的位置。将 g 移动到第一个要反转的节点的前面，将 p 移动到第一个要反转的节点的位置上。以 m = 3，n=5 为例：

![](https://gitee.com/veal98/images/raw/master/img/20210224224201.png)

**通过头插法，将 p 后面的元素依次插到 p 的签名，g 的后面**。

![](https://gitee.com/veal98/images/raw/master/img/20210224224501.png)

最后返回 newHead.next 即可。

## ✅  具体代码 


```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        ListNode newHead = new ListNode(); // 新链表的头节点
        newHead.next = head; 
        // 遍历一遍原链表，找到位置 m-1 和 m
        ListNode g = newHead; // 位置 m-1 的节点
        ListNode p = g.next; // 位置 m 的节点
        int step = 0;
        while (step < m - 1) {
            g = g.next;
            p = p.next;
            step ++;
        }
        
        // 对 m~n 位置的节点,依次摘下使用头插法插入 g(位置 m-1) 的后面
        for (int i = 0; i < n - m; i ++) {
            ListNode removed = p.next;
            p.next = p.next.next; // 防止断链
            // 头插法
            removed.next = g.next;
            g.next = removed;
        }
        return newHead.next;
            
    }
}
```
