# 链表问题

---

## CD48. 打印两个升序链表具有相同值的部分

【题目链接】：

- NowCoder：[CD48. 打印两个升序链表的公共部分](https://www.nowcoder.com/practice/8943eea40dbb4185b187d80fd050fee9?tpId=101&tqId=33116&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定两个升序链表，打印两个升序链表的公共部分。（题意表述的不清楚，其实是打印出两个升序链表具有相同值的部分）

输入描述:

```
第一个链表的长度为 n。

第二个链表的长度为 m。

链表结点的值为 val。
```

输出描述:

```
输出一行整数表示两个升序链表的公共部分的值 (按升序输出)。
```

示例1

```
输入
4
1 2 3 4
5
1 2 3 5 6

输出
1 2 3
```

示例2

```
输入
3
1 3 6
3
3 4 6

输出
3 6
```

【解题思路】：

很简单吧，获取两个升序链表中具有相同值得元素，使用**归并**思想，从两个链表的头开始进行如下判断：

- 如果 head1 的值小于 head2，则 head1 往下移动。
- 如果 head2 的值小于 head1，则 head2 往下移动。
- 如果 head1 的值与 head2 的值相等，则打印这个值，然后 head1 与 head2 都往下移动。
- head1 或 head2 有任何一个移动到 null，则整个过程停止。

【具体代码】：

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 第一个链表的长度
        ListNode head1 = new ListNode(-1); // 第一个链表的头节点
        ListNode p = head1;
        for (int i = 0; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;

        }
        int m = sc.nextInt(); // 第二个链表的长度
        ListNode head2 = new ListNode(-1); // 第二个链表的头节点
        ListNode q = head2;
        for (int i = 0; i < m; i ++) {
            q.next = new ListNode(sc.nextInt());
            q = q.next;
        }

        List<Integer> res = getCommonPart(head1.next, head2.next);
        for (int num : res) {
            System.out.print(num + " ");
        }
    }
    
    // 定义链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }

    private static List<Integer> getCommonPart(ListNode head1, ListNode head2) {
        List<Integer> res = new ArrayList<>();
        ListNode p = head1;
        ListNode q = head2;

        while (p != null && q != null) {
            if (p.val == q.val) {
                res.add(p.val);
                p = p.next;
                q = q.next;
            }
            else if (p.val < q.val) {
                p = p.next;
            }
            else { // p.val >= q.val
                q = q.next;
            }
        }

        return res;
    }
}
```

## CD106. 删除链表的第 K 个节点

【题目链接】：

- NowCoder：[删除链表的第 K 个节点](https://www.nowcoder.com/practice/0796dbf0eb054716937b0b82e0671c5f?tpId=101&tqId=33174&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一个链表，实现删除链表第 K 个节点的函数。

输入描述:

```
n 表示链表的长度。

m 表示删除链表第几个节点。

val 表示链表节点的值。
```

输出描述:

```
在给定的函数中返回链表的头指针。
```

示例1

```
输入
5 3
1 2 3 4 5

输出
1 2 4 5
```

【解题思路】：

没啥难度，找到第 k 个节点的前驱节点就行了

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 链表的长度
        int k = sc.nextInt(); // 第 k 个节点
        ListNode head = new ListNode(-1); // 头节点
        ListNode p = head;
        for (int i = 0; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;
        }

        removeKthNode(head.next, k);

        ListNode q = head.next;
        while (q != null) {
            System.out.print(q.val + " ");
            q = q.next;
        }
    }

    // 定义链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }

    // 删除链表的倒数第 k 个元素
    private static ListNode removeKthNode(ListNode head, int k) {
        ListNode p = head;
        ListNode pre = head; // 前驱节点

        for (int i = 1; i < k; i ++) {
            pre = p;
            p = p.next;
        }

        // 删除第 k 个节点
        pre.next = p.next;

        return head;
    }
}
```



## CD49/LC19. 删除链表的倒数第 K 个节点

【题目链接】：

- NowCoder：[CD49. 在链表中删除倒数第 K 个节点](https://www.nowcoder.com/practice/e5d90aac4c8b4628aa70d9b6597c0560?tpId=101&tqId=33117&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[19. 删除链表的倒数第 N 个节点 — Meidum](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

【题目描述】：

给出一个单链表，返回删除单链表的倒数第 K 个节点的链表。

输入描述:

```
n 表示链表的长度。
val 表示链表中节点的值。
```

输出描述:

```
在给定的函数内返回链表的头指针。
```

示例1

```
输入
5 4
1 2 3 4 5

输出
1 3 4 5
```

【解题思路】：

**快慢指针**。让快指针先走 `n` 步，然后快慢指针开始同速前进。这样当快指针走到链表最后一个元素时，慢指针所在的位置就是倒数第 `n` 个链表节点的前驱节点。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 链表的长度
        int k = sc.nextInt(); // 倒数第 k 个节点
        ListNode head = new ListNode(-1); // 头节点
        ListNode p = head;
        for (int i = 0; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;
        }

        removeLastKthNode(head.next, k);

        ListNode q = head.next;
        while (q != null) {
            System.out.print(q.val + " ");
            q = q.next;
        }
    }

    // 定义链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }

    // 删除链表的倒数第 k 个元素
    private static ListNode removeLastKthNode(ListNode head, int k) {
        ListNode fast = head;
        ListNode slow = head;

        while (k > 0) {
            fast = fast.next;
            k --;
        }

        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        // 找到了倒数第 k 个节点的前驱节点
        ListNode kNode = slow.next;
        // 删除第 k 个节点
        slow.next = kNode.next;

        return head;
    }
}
```

## CD107. 反转单向链表和双向链表

【题目链接】：

- NowCoder：[CD107. 反转单向链表和双向链表](https://www.nowcoder.com/practice/b66a251dec8847f386bbe6cd96b7e9c8?tpId=101&tqId=33175&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

实现反转单向链表和双向链表的函数。

如 1->2->3 反转后变成 3->2->1。

输入描述:

```
第一行一个整数 n，表示单链表的长度。

第二行 n 个整数 val 表示单链表的各个节点。

第三行一个整数 m，表示双链表的长度。

第四行 m 个整数 val 表示双链表的各个节点。
```

输出描述:

```
在给定的函数内返回相应链表的头指针。
```

示例1

```
输入
3
1 2 3
4
1 2 3 4

输出
3 2 1
4 3 2 1
```

【解题思路】：

反转单向链表和反转双向链表的思路是一样的，只不过双向链表多处理一下 pre 指针罢了。

这里以单向链表为例，讲解一下反转链表的两种方法：

1）**第一种：新链表 + 头插法**

首先新建 newHead 节点作为新链表的头节点；然后使用头插法依次从原链表取下节点插入 newHead 的后面。最后返回 newHead.next 即可

![](https://gitee.com/veal98/images/raw/master/img/20210224233624.png)

```java
// 反转单链表 (使用头节点+新链表的方式)
private static ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }

    ListNode newHead = new ListNode(-1); // 新链表的头节点
    newHead.next = null;

    // 不断地把原链表的节点摘下来头插到新链表上
    while (head != null) {
        ListNode temp = head.next; // 防止断链

        // 头插法
        head.next = newHead.next;
        newHead.next = head;

        // 开始下一次循环
        head = temp;
    }

    return newHead.next;
}
```

2）**第二种：原地反转**

主要是利用两个辅助的结点，不断地循环更改指针的指向：

- preNode 和 next 分别代表当前要处理的节点的前一个结点和后一个结点
- 通过改变结点的 next 域的指向来反转整个链表，通过循环处理，每次反转一个之后，preNode 指向下一个结点，也就是 head，head 更改为 head 的下一个结点，也就是 next，这样直到 head 为空，返回 preNode 就反转了整个单链表

```java
public static ListNode reverseList(ListNode head){
      ListNode preNode = null;
      while(head != null) {
            ListNode next = head.next;
          
            head.next = preNode;
            preNode = head;
            head = next;
      }
      return pre;
}
```

【具体代码】：这里对于单链表我采用新链表 + 头插法的方式，对于双链表采用原地反转的方式。

```java
import java.util.Scanner;

public class CD107 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt(); // 单链表的长度
        ListNode head1 = new ListNode(sc.nextInt()); // 第一个元素节点
        ListNode p = head1;
        for (int i = 1; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;
        }

        int m = sc.nextInt(); // 双链表的长度
        DoubleListNode head2 = new DoubleListNode(sc.nextInt()); // 第一个元素节点
        DoubleListNode q = head2;
        for (int i = 1; i < m; i ++) {
            DoubleListNode node = new DoubleListNode(sc.nextInt());
            q.next = node;
            node.pre = q;

            q = q.next;
        }

        // 反转单链表
        ListNode newHead1 = reverseList(head1);
        ListNode cur1 = newHead1;
        while (cur1 != null) {
            System.out.print(cur1.val + " ");
            cur1 = cur1.next;
        }

        System.out.println();

        // 反转双链表
        DoubleListNode newHead2 = reverseDoubleList(head2);
        DoubleListNode cur2 = newHead2;
        while (cur2 != null) {
            System.out.print(cur2.val + " ");
            cur2 = cur2.next;
        }

    }

    // 定义单链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }

    // 定义双链表结构
    public static class DoubleListNode {
        private int val;
        private DoubleListNode next;
        private DoubleListNode pre;

        public DoubleListNode(int val) {
            this.val = val;
        }
    }

    // 反转单链表 (使用头节点+新链表的方式)
    private static ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode newHead = new ListNode(-1); // 新链表的头节点
        newHead.next = null;

        // 不断地把原链表的节点摘下来头插到新链表上
        while (head != null) {
            ListNode temp = head.next; // 防止断链

            // 头插法
            head.next = newHead.next;
            newHead.next = head;

            head = temp;
        }

        return newHead.next;
    }

    // 反转双链表(采用原地反转的方式)
    private static DoubleListNode reverseDoubleList(DoubleListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        DoubleListNode preNode = null; // 当前正在处理节点的前驱节点
        while (head != null) {
            DoubleListNode temp = head.next; // 防止断链

            head.next = preNode;
            head.pre = temp;

            preNode = head;
            head = temp;
        }

        return preNode;
    }

}
```

## CD108/LC92. 反转部分单向链表

【题目链接】：

- NowCoder：[反转部分单向链表](https://www.nowcoder.com/practice/f11155006f154419b0bef6de8918aea2?tpId=101&tqId=33176&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

【题目描述】：

给定一个单链表，在链表中把第 L 个节点到第 R 个节点这一部分进行反转。

输入描述:

```
n 表示单链表的长度。

val 表示单链表各个节点的值。

L 表示翻转区间的左端点。

R 表示翻转区间的右端点。
```

输出描述:

```
在给定的函数中返回指定链表的头指针。
```

示例1

```
输入
5
1 2 3 4 5
1 3

输出
3 2 1 4 5
```

【解题思路】：

- 对于需要反转的部分，用头插法进行反转
- 对不需要反转的部分，不操作

具体做法：

首先新建 newHead 节点链接到原链表的 head 上，因为若 L = 1，需要 newHead 作为中介进行头插，相当于我们手动为这个链表加上了一个头节点。

核心思想：以 L-1 为头节点， L 为尾节点，将 L 后面的 R-L 个元素依次摘下头插到 L 前面

![](https://gitee.com/veal98/images/raw/master/img/20210409181531.png)

🚨 **注意最后需要将 R 这个节点链接到 L 后面那个节点，防止出现环**

最后返回 newHead.next 即可。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt(); // 单链表的长度
        ListNode head = new ListNode(sc.nextInt()); // 第一个元素节点
        ListNode p = head;
        for (int i = 1; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;
        }

        int L = sc.nextInt(); // 左端点
        int R = sc.nextInt(); // 右端点

        ListNode head2 = reversePart(head, L, R);

        ListNode temp = head2;
        while (temp != null) {
            System.out.print(temp.val + " ");
            temp = temp.next;
        }

    }

    private static ListNode reversePart(ListNode head, int L, int R) {
        if (L >= R) {
            return head;
        }

        // 添加头节点，方便处理 L 是 head 的情况
        ListNode newHead = new ListNode(-1);
        newHead.next = head;


        // 找到 L 的前驱节点
        ListNode lPreNode = newHead;
        for (int i = 0; i < L-1; i ++) {
            lPreNode = lPreNode.next;
        }
        ListNode lNode = lPreNode.next; // 第 L 个节点

        // 从第 L+1 个节点开始头插
        ListNode p = lNode.next; // 第 L+1 个节点
        ListNode temp = p; // p 的后继节点，防止断链
        for (int i = 0; i < R-L; i ++) {
            temp = p.next; // 防止断链

            p.next = lPreNode.next;
            lPreNode.next = p;

            p = temp; // 继续下一个节点的处理
        }

        // 防止出现环
        lNode.next = temp;

        return newHead.next;
    }

    // 定义单链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }
}
```

## CD109. 环形链表的约瑟夫问题

【题目链接】：

- NowCoder：[CD109. 环形链表的约瑟夫问题](https://www.nowcoder.com/practice/c3b34059faf546d3a7ee28f2b0154286?tpId=101&tqId=33177&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

据说著名犹太历史学家 Josephus 有过以下故事：在罗马人占领乔塔帕特后，39 个犹太人与 Josephus 及他的朋友躲到一个洞中，39 个犹太人决定宁愿死也不要被敌人抓到，于是决定了一种自杀方式，41 个人排成一个圆圈，由第 1 个人开始报数，报数到 3 的人就自杀，然后再由下一个人重新报 1，报数到 3 的人再自杀，这样依次下去，直到剩下最后一个人时，那个人可以自由选择自己的命运。这就是著名的约瑟夫问题。现在请用单向环形链表得出最终存活的人的编号。

输入描述:

```
一行两个整数 n 和 m， n 表示环形链表的长度， m 表示每次报数到 m 就自杀。
```

输出描述:

```
输出最后存活下来的人编号(编号从1开始到n)
```

示例1

```
输入
5 2

输出
3
```

【解题思路】：

使用一个计数器（初始值赋为 1），然后直接循环遍历就好了。其中删除节点的时候需要前驱节点，单向循环链表里的最后一个节点就是天然的前驱节点（head 的前驱节点），直接用它就行：

- 如果链表为空或者链表节点数为 1，或者 m 的值小于 1，则不用调整就直接返回。
- 在环形链表中遍历每个节点，不断转圈，不断让每个节点报数（count ++）
- 当报数到达 m 时，就删除当前报数的节点。并将 count 归 1
- 不停地删除，直到环形链表中只剩一个节点，过程结束。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 环形链表长度
        int m = sc.nextInt(); // 报数

        // 构造环形链表
        ListNode head = new ListNode(1); // 第一个节点
        ListNode p = head; // 工作指针
        for (int i = 2; i <= n; i ++) {
            p.next = new ListNode(i);
            p = p.next;
        }
        p.next = head; // 成环

        System.out.println(josephusKill(head, m).val);
    }

    // 返回最后存活的节点
    private static ListNode josephusKill(ListNode head, int m) {
        if (head == null || head.next == head || m < 1) {
            return head;
        }

        // 找到链表的最后一个节点（天然的前驱节点）
        ListNode last = head;
        while (last.next != head) {
            last = last.next;
        }

        // 循环报数
        int count = 1;
        while (head != last) {
            // 删除当前节点
            if (count == m) {
                last.next = head.next;
                head = last.next;
                count = 1;
            }
            else {
                last = last.next;
                head = head.next;
                count ++;
            }
        }

        return head;
    }

    // 定义单链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }
}
```

【时间复杂度】：

每删除一个节点，都需要遍历 m 次，一共需要删除的节点数为 n-1，所以上述解法的时间复杂度为 O(n×m)

## CD113. 将单向链表按某值划分为左边小，中间相等，右边大的形式

【题目链接】：

- NowCoder：[CD113. 将单向链表按某值划分为左边小，中间相等，右边大的形式](https://www.nowcoder.com/practice/04fcabc5d76e428c8100dbd855761778?tpId=101&tqId=33181&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一个链表，再给定一个整数 pivot，请将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点， 右边部分都是大于 pivot 的节点。

除此之外，对调整后的节点顺序没有更多要求。

例如：链表 9->0->4->5->1，pivot=3。

调整后链表可以是 1->0->4->9->5，也可以是 0->1->9->5->4。总之，满足左部分都是小于 3的节点，中间部分都是等于 3 的节点（本例中这个部分为空），右部分都是大于 3 的节点即可。对某部分内部的节点顺序不做要求。

输入描述:

```
第一行两个整数 n 和 pivot，n 表示链表的长度。

第二行 n 个整数 ai 表示链表的节点。
```

输出描述:

```
请在给定的函数内返回链表的头指针。
```

示例1

```
输入
5 3
9 0 4 5 1

输出
1 0 4 5 9
```

【解题思路】：

思路其实也不难，就是将原链表中的所有节点依次划分进三个链表，三个链表分别为 small 代表左部分，equal代表中间部分，big 代表右部分。

例如，链表 7->9->1->8->5->2->5，pivot=5。在划分之后，small、equal、big 分别为：

- small：1->2->null
- equal：5->5->null 
- big：7->9->8->null

将 small、equal 和 big 三个链表重新串起来即可。整个过程需要特别注意对 null 节点的判断和处理。

【具体代码】：

```java
import java.util.List;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 链表长度
        int pivot = sc.nextInt();

        // 构造链表
        ListNode head = new ListNode(sc.nextInt()); // 第一个节点
        ListNode p = head; // 工作指针
        for (int i = 1; i < n; i ++) {
            p.next = new ListNode(sc.nextInt());
            p = p.next;
        }

        ListNode head2 = listPartition(head, pivot);
        ListNode cur = head2;
        while (cur != null) {
            System.out.print(cur.val + " ");
            cur = cur.next;
        }

    }

    private static ListNode listPartition(ListNode head, int pivot) {
        if (head == null) {
            return head;
        }

        ListNode sH = null; // 小的头
        ListNode sT = null; // 小的尾
        ListNode eH = null; // 相等的头
        ListNode eT = null; // 相等的尾
        ListNode bH = null; // 大的头
        ListNode bT = null; // 大的尾

        while (head != null) {
            ListNode temp = head.next; // 防止断链
            head.next = null; // 防止出现环

            // 放入小链表
            if (head.val < pivot) {
                if (sH == null) {
                    // 判断是否是第一个存入的元素
                    sH = head;
                    sT = head;
                }
                else {
                    sT.next = head;
                    sT = sT.next;
                }
            }
            // 放入相等的链表
            else if (head.val == pivot) {
                if (eH == null) {
                    eH = head;
                    eT = head;
                }
                else {
                    eT.next = head;
                    eT = eT.next;
                }
            }
            // 放入大链表
            else {
                if (bH == null) {
                    bH = head;
                    bT = head;
                }
                else {
                    bT.next = head;
                    bT = bT.next;
                }
            }

            head = temp;
        }


        // 小链表和相等的链表连接
        if (sT != null) {
            sT.next = eH;
            eT = (eT == null) ? sT : eT;
        }
        // 相等的链表和大链表连接
        if (eT != null) {
            eT.next = bH;
        }

        return (sH != null) ? sH : (eH != null) ? eH : bH;
    }


    // 定义单链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }
}
```

注意这行代码，防止成环

![](https://gitee.com/veal98/images/raw/master/img/20210409223018.png)

## LC138. 复制带随机指针的链表

【题目链接】：

- NowCoder：[LC138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

【题目描述】：

给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。

例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。

返回复制链表的头节点。

用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

- val：一个表示 Node.val 的整数。
- random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。

你的代码 只 接受原链表的头节点 head 作为传入参数。

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

示例 3：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```


示例 4：

```
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
```

【解题思路】：

方法一：先遍历一遍链表，使用哈希表保存原节点和副本节点的对应关系，然后再遍历一遍节点，处理一下 random 指针。

![](https://gitee.com/veal98/images/raw/master/img/20210411215037.png)

哈希表增删改查的操作时间复杂度都是 O(1)，普通方法一共只遍历链表两遍，所以上述解法的时间复杂度为 O(N)。因为使用了哈希表，所以额外空间复杂度为 O(N)。

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }
        // 使用哈希表保存原节点和副本节点的关系
        Map<Node, Node> map = new HashMap<>();
        Node cur = head;
        while (cur != null) {
            map.put(cur, new Node(cur.val));
            cur = cur.next;
        }
        
        // 再遍历一遍链表处理 random 指针
        cur = head;
        while (cur != null) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        
        return map.get(head);
    }
}
```

方法二：

![](https://gitee.com/veal98/images/raw/master/img/20210411220953.png)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }
        
        // 创建副本节点并将其连接在对应的原节点后面
        Node cur = head;
        while (cur != null) {
            Node copy = new Node(cur.val);
            copy.next = cur.next;
            cur.next = copy;
            // 进入下一个节点的处理
            cur = copy.next;
        }
        
        // 再遍历一遍节点，处理 random 指针
        cur = head;
        while (cur != null) {
            Node copy = cur.next; // 副本节点
            copy.random = cur.random != null ? cur.random.next : null;
            // 进入下一个节点的处理
            cur = copy.next;
        }
        
        // 分离原节点和副本节点
        Node res = head.next;
        cur = head;
        while (cur != null) {
            Node temp = cur.next.next; // 下一个原节点
            Node copy = cur.next;
            cur.next = temp;
            copy.next = temp != null ? temp.next : null;
            
            cur = temp;
        }
        
        return res;
    }
}
```

## CD114/LC2. 两个链表生成相加链表

【题目链接】：

- NowCoder：[CD114. 两个链表生成相加链表](https://www.nowcoder.com/practice/2d4ae9ef94c8412ebe49118f8e1da2df?tpId=101&tqId=33182&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- LeetCode：[2. 两数相加 - Medium](https://leetcode-cn.com/problems/add-two-numbers/)

【题目描述】：

假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。

给定两个这种链表，请生成代表两个整数相加值的结果链表。

例如：链表 1 为 9->3->7，链表 2 为 6->3，最后生成新的结果链表为 1->0->0->0。

输入描述:

```
第一行两个整数 n 和 m，分别表示两个链表的长度。

第二行 n 个整数 ai 表示第一个链表的节点。

第三行 m 个整数 bi 表示第二个链表的节点。
```

输出描述:

```
输出一行整数表示结果链表。
```

示例1

```
输入
3 2
9 3 7
6 3

输出
1 0 0 0
```

【解题思路】：

- 将两个链表逆序，这样就可以依次得到从低位到高位的数字
- 同步遍历两个逆序后的链表，这样就依次得到两个链表从低位到高位的数字，然后逐一计算两个链表的两数之和，将其插入新链表，同时需要关注每一步是否有进位
- 当两个链表都遍历完成后，还要关注最后一次的进位信息是否为 1，如果为 1，还要生成一个节点
  值为 1 的新节点。（比如 9 + 1 = 10，两个一位数相加，但是结果是两位数，因为最后一次的进位是 1）
- 最后，逆序新链表，返回新链表的表头节点即可。

【具体代码】：

```java
import java.util.List;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // 第一个链表的长度
        int m = sc.nextInt(); // 第二个链表的长度
        // 构造第一个链表
        ListNode head1 = new ListNode(sc.nextInt());
        ListNode cur = head1;
        for (int i = 1; i < n; i ++) {
            cur.next = new ListNode(sc.nextInt());
            cur = cur.next;
        }
        // 构造第二个链表
        ListNode head2 = new ListNode(sc.nextInt());
        cur = head2;
        for (int i = 1; i < m; i ++) {
            cur.next = new ListNode(sc.nextInt());
            cur = cur.next;
        }

        ListNode res = addList(head1, head2);
        cur = res;
        while (cur != null) {
        	System.out.println(cur.val + " ");
            cur = cur.next;
        }
    }

    // 两个链表相加
    private static ListNode addList(ListNode head1, ListNode head2) {
        if (head1 == null || head2 == null) {
            return (head1 == null) ? head2 : head1;
        }
        head1 = reverseList(head1);
        head2 = reverseList(head2);
        ListNode res = new ListNode(-1);
        ListNode p = res;

        ListNode cur1 = head1;
        ListNode cur2 = head2;
        int carry = 0; // 进位
        while (cur1 != null || cur2 != null) {
            int n1 = (cur1 == null) ? 0 : cur1.val;
            int n2 = (cur2 == null) ? 0 : cur2.val;
            int sum = n1 + n2 + carry;
            if (sum > 9) {
                p.next = new ListNode(sum - 10);
                p = p.next;
                carry = 1;
            }
            else {
                p.next = new ListNode(sum);
                p = p.next;
                carry = 0;
            }

            // 进入下一个节点的相加
            cur1 = (cur1 == null) ? null : cur1.next;
            cur2 = (cur2 == null) ? null : cur2.next;
        }

        // 注意最后一位进位的判断
        if (carry == 1) {
            p.next = new ListNode(1);
        }

        return reverseList(res.next);
    }

    // 原地反转单链表
    private static ListNode reverseList(ListNode head) {
        ListNode preNode = null; // 前驱节点
        while (head != null) {
            ListNode temp = head.next;

            head.next = preNode;
            preNode = head;

            // 进入下一个节点的判断
            head = temp;
        }
        return preNode;
    }

    // 定义单链表结构
    public static class ListNode {
        private int val;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }
}
```

上述代码只能通过 80% 的案例，之前栈和队列章节 - CD188 题单调栈进阶那道题目也出现了这种情况。轻车熟路，考虑是 IO 次数太多导致的，用 StringBuilder 保存结果，然后一次性输出：

```java
ListNode res = addList(head1, head2);
cur = res;
StringBuilder sb = new StringBuilder();
while (cur != null) {
    sb.append(cur.val);
    sb.append(" ");
    cur = cur.next;
}
System.out.println(sb);
```

