# 二叉树问题

---

## 定义并构建二叉树公共代码

> 这套代码在以后的解题代码中就不贴了，都是一样的，如果有不同之处，我会再指出来的。

二叉树的定义如下：

```java
// 定义二叉树
static class TreeNode {
    private int val;
    private TreeNode left;
    private TreeNode right;

    public TreeNode (int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}
```

下面这套构建二叉树的代码对应如下的输入格式：

第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch 同理)

示例

```
输入
3 1
1 2 3
2 0 0
3 0 0
```

【具体代码】：

```java
// 构造二叉树
private static TreeNode createTree(Scanner sc) {
    String[] values = sc.nextLine().split(" ");
    if (values.length < 3) {
        return null;
    }

    int value = Integer.parseInt(values[0]);
    int left = Integer.parseInt(values[1]);
    int right = Integer.parseInt(values[2]);

    TreeNode root = new TreeNode(value);
    if (left != 0) {
        root.left = createTree(sc);
    }
    if (right != 0) {
        root.right = createTree(sc);
    }

    return root;
}

public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    sc.nextLine(); // 第一行没啥用
    TreeNode root = createTree(sc);
}
```

## CD161. 实现二叉树先序，中序和后序遍历

【题目链接】：

- NowCoder：[CD161. 实现二叉树先序，中序和后序遍历](https://www.nowcoder.com/practice/566f7f9d68c24691aa5abd8abefa798c?tpId=101&tqId=33229&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

分别按照二叉树先序，中序和后序打印所有的节点。

输入描述:

第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

输出描述:

输出三行，分别表示二叉树的先序，中序和后序。

示例1

```
输入
3 1
1 2 3
2 0 0
3 0 0

输出
1 2 3
2 1 3
2 3 1
```

【解题思路】：

下面代码给出了遍历的递归和非递归版本。另外如何构建二叉树也需要注意。

【具体代码】：

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行数据没啥用
        TreeNode root = createTree(sc);

        List<Integer> preOrderList = preOrderUnRecur(root);
        for (int i : preOrderList) {
            System.out.print(i + " ");
        }
        System.out.println();

        List<Integer> inOrderList = inOrderUnRecur(root);
        for (int i : inOrderList) {
            System.out.print(i + " ");
        }
        System.out.println();

        List<Integer> postOrderList = postOrderUnRecur(root);
        for (int i : postOrderList) {
            System.out.print(i + " ");
        }
        System.out.println();
    }

    // 先序遍历 - 递归
    private static List<Integer> preOrderRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>(); // 存储遍历结果
        if (root == null) {
            return res;
        }

        res.add(root.val);
        preOrderRecur(root.left);
        preOrderRecur(root.right);

        return res;
    }
    // 中序遍历 - 递归
    private static List<Integer> inOrderRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        inOrderRecur(root.left);
        res.add(root.val);
        inOrderRecur(root.right);

        return res;
    }
    // 后序遍历 - 递归
    private static List<Integer> postOrderRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        postOrderRecur(root.left);
        postOrderRecur(root.right);
        res.add(root.val);

        return res;
    }

    // 先序遍历 - 非递归
    private static List<Integer> preOrderUnRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                res.add(cur.val);
                cur = cur.left;
            }
            else {
                cur = stack.pop();
                cur = cur.right;
            }
        }

        return res;
    }
    // 中序遍历 - 非递归
    private static List<Integer> inOrderUnRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            else {
                cur = stack.pop();
                res.add(cur.val);
                cur = cur.right;
            }
        }

        return res;
    }
    // 后序遍历 - 非递归
    private static List<Integer> postOrderUnRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        TreeNode recently = null; // 最近访问过的节点
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            else {
                // 获取栈顶元素
                cur = stack.peek();
                // 右孩子存在且未被访问过
                if (cur.right != null && recently != cur.right) {
                    cur = cur.right;
                    stack.push(cur);
                    cur = cur.left;
                }
                // 右孩子不存在或者已被访问过或者右孩子不存在
                else {
                    cur = stack.pop();
                    res.add(cur.val);
                    recently = cur; // 设为最近访问节点
                    cur = null; // cur 重置(即继续获取栈顶元素并对其进行判断)
                }
            }

        }

        return res;
    }
}
```

## LC102/SO32. 层次遍历

【题目链接】：

- LeetCode：[102. 二叉树的层序遍历 — Medium](https://leetcode-cn.com/problems/binary-tree-level-order-traversal) 
- 剑指 Offer：[32 - II. 从上到下打印二叉树 II — Easy](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

【题目描述】：

给你一个二叉树，请你返回其按 层序遍历 得到的节点值（即逐层地，从左到右访问所有节点）。

示例：

```
二叉树：[3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7

返回其层序遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
```

【解题思路】：

利用队列先进先出的特性（广度优先搜索）

【具体代码】：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        
        if(root == null)
            return res;
        
        queue.offer(root); // 队列尾部添加元素。offer 方法在超出队列界限的时候直接返回 false
        
        while(!queue.isEmpty()){
            List<Integer> level = new ArrayList<Integer>(); // 存储每个层的节点
            int currentLevelSize = queue.size();
            for (int i = 0; i < currentLevelSize; i ++){
                TreeNode node = queue.poll();
                level.add(node.val);
                if(node.left != null)
                    queue.offer(node.left);
                if(node.right != null)
                    queue.offer(node.right);
            }
            
            res.add(level);  
        }
        
        return res;
    }
}
```

## CD168/SO32. 二叉树的按层打印与 ZigZag 打印

【题目链接】：

- NowCoder：[CD168. 二叉树的按层打印与 ZigZag 打印](https://www.nowcoder.com/practice/6a1815a85bfc411d9295bc017e6b6dbe?tpId=101&tqId=33236&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- 剑指 Offer：[32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

【题目描述】：

给定一颗二叉树，分别实现按层和 ZigZag 打印二叉树。

ZigZag遍历: 意思是第一层从左到右遍历，第二层从右到左遍历，依次类推。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
先输出按层打印，再输出按ZigZag打印。
```

示例1

```
输入
8 1
1 2 3
2 4 0
4 0 0
3 5 6
5 7 8
6 0 0
7 0 0
8 0 0

输出
Level 1 : 1
Level 2 : 2 3
Level 3 : 4 5 6
Level 4 : 7 8
Level 1 from left to right: 1
Level 2 from right to left: 3 2
Level 3 from left to right: 4 5 6
Level 4 from right to left: 8 7
```

【解题思路】：

层次遍历没什么好说的。ZigZag 遍历也直接层次遍历，只不过奇数偶数行元素的插入顺序不一样。可以使用 LinkedList 双向链表存储每行数据，既能在头部添加（`addFirst`）也能在尾部添加（`addLast`）

【具体代码】：

> 这段代码无法 AC，尚未找到原因所在

```java
import java.util.*;

public class CD168 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);

        // 按层打印
        List<List<Integer>> levelList = printByLevel(root);
        for (int i = 0; i < levelList.size(); i ++) {
            System.out.print("Level " + (i + 1) + " : ");
            for (int j = 0; j < levelList.get(i).size(); j ++) {
                System.out.print(levelList.get(i).get(j) + " ");
            }
            System.out.println();
        }

        // zigZag 打印
        List<List<Integer>> zigzagList = printByZigzag(root);
        for (int i = 0; i < zigzagList.size(); i ++) {
            String lStr = "left";
            String rStr = "right";
            if ((i+1) % 2 == 0) {
                lStr = "right";
                rStr = "left";
            }
            System.out.print("Level " + (i + 1) + " from " + lStr + " to " + rStr + " : ");
            for (int j = 0; j < zigzagList.get(i).size(); j ++) {
                System.out.print(zigzagList.get(i).get(j) + " ");
            }
            System.out.println();
        }

    }

    // 按层打印
    private static List<List<Integer>> printByLevel(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>(); // 存储遍历结果
        if (root == null) {
            return res;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int sz = queue.size();
            List<Integer> level = new ArrayList<>(); // 存储每行遍历的结果
            for (int i = 0; i < sz; i ++) {
                TreeNode node = queue.poll();
                level.add(node.val);

                if(node.left != null)
                    queue.offer(node.left);
                if(node.right != null)
                    queue.offer(node.right);
            }
            res.add(level);
        }

        return res;
    }

    // zigZag 打印
    private static List<List<Integer>> printByZigzag(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>(); // 存储遍历结果
        if (root == null) {
            return res;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        int height = 1;

        while (!queue.isEmpty()) {
            int sz = queue.size();
            // 双向链表存储每行数据，既能在头部添加也能在尾部添加
            LinkedList<Integer> line = new LinkedList<>();
            for (int i = 0; i < sz; i ++) {
                TreeNode cur = queue.poll();

                if (height % 2 != 0) {
                    // 奇数行
                    line.addLast(cur.val);
                }
                else {
                    // 偶数行
                    line.addFirst(cur.val);
                }

                if (cur.left != null) {
                    queue.offer(cur.left);
                }
                if (cur.right != null) {
                    queue.offer(cur.right);
                }
            }
            res.add(line);
            height ++;
        }

        return res;
    }
}
```

## CD162. 打印二叉树的边界节点

【题目链接】：

- NowCoder：[CD161. 实现二叉树先序，中序和后序遍历](https://www.nowcoder.com/practice/566f7f9d68c24691aa5abd8abefa798c?tpId=101&tqId=33229&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一颗二叉树的根节点 root，按照如下两种标准分别实现二叉树的边界节点的逆时针打印。

标准一：

1，根节点为边界节点。

2，叶节点为边界节点。

3，如果节点在其所在的层中是最左的或最右的，那么该节点也是边界节点。

标准二：

1，根节点为边界节点。

2，叶节点为边界节点。

3，树左边界延伸下去的路径为边界节点。

4，树右边界延伸下去的路径为边界节点。

ps: 具体请对照样例

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
输出两行整数分别表示按两种标准的边界节点。
```

示例 1:

<img src="https://gitee.com/veal98/images/raw/master/img/20210418153718.png" style="zoom:80%;" />

```
输入
16 1
1 2 3
2 0 4
4 7 8
7 0 0
8 0 11
11 13 14
13 0 0
14 0 0
3 5 6
5 9 10
10 0 0
9 12 0
12 15 16
15 0 0
16 0 0
6 0 0

输出
1 2 4 7 11 13 14 15 16 12 10 6 3
1 2 4 7 13 14 15 16 10 6 3
```

【解题思路】：

对于标准一：

![](https://gitee.com/veal98/images/raw/master/img/20210418154232.png)

对于标准二：

![](https://gitee.com/veal98/images/raw/master/img/20210418154416.png)

【具体代码】：

```java

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行不重要
        TreeNode root = createTree(sc);

        List<Integer> edge1 = printEdge1(root);
        for (int i : edge1) {
            System.out.print(i + " ");
        }

        System.out.println();

        List<TreeNode> edge2 = new ArrayList<>();
        printEdge2(root, edge2);
        for (TreeNode node : edge2) {
            System.out.print(node.val + " ");
        }
    }

    // 按照标准一输出边界
    private static List<Integer> printEdge1(TreeNode root) {
        List<Integer> res = new ArrayList<>(); // 存储结果
        if (root == null) {
            return res;
        }

        int height = getHeight(root); // 获取二叉树高度
        // 存储每层的最左和最右节点
        // edgeMap[i][0] 表示第 i 层的最左节点
        // edgeMap[i][1] 表示第 i 层的最右节点
        TreeNode[][] edgeMap = new TreeNode[height][2];
        setEdgeMap(root, 0, edgeMap);

        // 打印左边界
        for (int i = 0; i < edgeMap.length; i ++) {
            res.add(edgeMap[i][0].val);
        }

        // 打印既不是左边界也不是右边界的叶子节点
        List<TreeNode> leafNotInMapList = new ArrayList<>();
        getLeafNotInMap(root, 0, edgeMap, leafNotInMapList);
        for (TreeNode node : leafNotInMapList) {
            res.add(node.val);
        }

        // 打印右边界(自下向上),但不是左边界的节点
        for (int i = edgeMap.length-1; i >= 0; i --) {
            if (edgeMap[i][0] != edgeMap[i][1]) {
                res.add(edgeMap[i][1].val);
            }
        }

        return res;
    }

    // 递归获取二叉树高度
    private static int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {
            return 1;
        }

        int leftHeight = getHeight(root.left);
        int rightHeight = getHeight(root.right);

        return Math.max(leftHeight, rightHeight) + 1;
    }

    /**
     * 递归存储每层的最左和最右节点
     * @param root
     * @param h 第几层
     * @param edgeMap
     */
    private static void setEdgeMap(TreeNode root, int h, TreeNode[][] edgeMap) {
        if (root == null) {
            return ;
        }

        edgeMap[h][0] = (edgeMap[h][0] == null) ? root : edgeMap[h][0];
        edgeMap[h][1] = root;

        setEdgeMap(root.left, h + 1, edgeMap);
        setEdgeMap(root.right, h + 1, edgeMap);
    }

    // 获取既不是左边界也不是右边界的叶子节点
    private static void getLeafNotInMap(TreeNode root, int h, TreeNode[][] edgeMap, List<TreeNode> leafNotInMapList) {
        if (root == null) {
            return ;
        }

        if (root.left == null && root.right == null &&
            root != edgeMap[h][0] && root != edgeMap[h][1]) {
            leafNotInMapList.add(root);
        }

        getLeafNotInMap(root.left, h + 1, edgeMap, leafNotInMapList);
        getLeafNotInMap(root.right, h + 1, edgeMap, leafNotInMapList);

    }


    // 按照标准二输出边界
    private static void printEdge2(TreeNode root, List<TreeNode> edgeList) {
        if (root == null) {
            return ;
        }

        edgeList.add(root); // 头节点符合标准二的要求

        if (root.left != null && root.right != null) {
            // 打印左边界的延伸路径，以及 root 左子树上所有的叶节点
            List<TreeNode> leftEdgeList = new ArrayList<>();
            getLeftEdge(root.left, true, leftEdgeList);
            for (TreeNode node : leftEdgeList) {
                edgeList.add(node);
            }
            // 打印右边界的延伸路径，以及 root 右子树上所有的叶节点
            List<TreeNode> rightEdgeList = new ArrayList<>();
            getRightEdge(root.right, true, rightEdgeList);
            for (TreeNode node : rightEdgeList) {
                edgeList.add(node);
            }
        }
        else {
            printEdge2((root.left != null) ? root.left : root.right, edgeList);
        }
    }

    private static void getLeftEdge(TreeNode root, boolean print, List<TreeNode> leftEdgeList) {
        if (root == null) {
            return ;
        }

        // 叶子节点
        if (print == true || (root.left == null && root.right == null)) {
            leftEdgeList.add(root);
        }

        getLeftEdge(root.left, print, leftEdgeList);
        getLeftEdge(root.right, (print == true && root.left == null) ? true : false, leftEdgeList);
    }

    private static void getRightEdge(TreeNode root, boolean print, List<TreeNode> rightEdgeList) {
        if (root == null) {
            return ;
        }

        getRightEdge(root.left, (print == true && root.right == null) ? true : false, rightEdgeList);
        getRightEdge(root.right, print, rightEdgeList);

        // 叶子节点
        if (print || (root.left == null && root.right == null)) {
            rightEdgeList.add(root);
        }
    }

}
```

## CD163/LC297/SO37. 二叉树的序列化和反序列化

【题目链接】：

- NowCoder：[CD163. 二叉树的序列化和反序列化](https://www.nowcoder.com/practice/d6425eab86fc402085f9fafc0db97cc2?tpId=101&tqId=33231&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- 剑指 Offer ：[剑指 Offer 37. 序列化二叉树 — Hard](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)
- LeetCode：[297. 二叉树的序列化与反序列化 — Hard](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)
- 牛客题霸.：[序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=117&tqId=37782&companyId=134&rp=1&ru=%2Fcompany%2Fhome%2Fcode%2F134&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey)

【题目描述】：

二叉树被记录为文件的过程叫作二叉树的序列化，通过文件内容重建原来二叉树的过程叫作二叉树的反序列化，给定一颗二叉树，请将该二叉树先序序列化和层序序列化。

假设序列化的结果字符串为 str，初始时 str = ""，遍历二叉树时，遇到 null 节点，则在 str 的末尾加上 "#!"，否则加上"当前的节点值!"。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
输出两行分别表示该二叉树的先序序列化和层序序列化
```

示例1

```
输入
2 1
1 2 0
2 0 0

输出
1!2!#!#!#!
1!2!#!#!#!
```

【解题思路】：

1）利用**先序遍历**来序列化和反序列化（这种比较好理解）

先序遍历的反序列化其实就是重做先序遍历，遇到 "#" 就生成 null 节点，结束生成后续子树的过程。

```java
	// 序列化 - 先序遍历
    private static String serializeByPre(TreeNode root) {
        if (root == null) {
            return "#!";
        }

        StringBuilder res = new StringBuilder(); // 存储序列化后的结果
        res.append(root.val).append("!");

        res.append(serializeByPre(root.left));
        res.append(serializeByPre(root.right));

        return res.toString();
    }
    // 反序列化 - 先序遍历
    private static TreeNode desrializeByPre(String str) {
        // 拆分字符串并一一入队
        String[] values = str.split("!");
        Queue<String> queue = new LinkedList<>();
        for (int i = 0; i < values.length; i ++) {
            queue.offer(values[i]);
        }

        return reconPreOrder(queue);
    }
    private static TreeNode reconPreOrder(Queue<String> queue) {
        // 每次弹出一个节点进行判断
        String value = queue.poll();
        if (value.equals("#")) { // 当前节点为空
            return null;
        }
        // 总是根据首位元素确定当前子树的根
        TreeNode root = new TreeNode(Integer.parseInt(value));
        root.left = reconPreOrder(queue);
        root.right = reconPreOrder(queue);

        return root;
    }
```

2）利用**层次遍历**来序列化和反序列化


与根据先序遍历的反序列化过程一样，根据层遍历的反序列化是重做层遍历，遇到 "#" 就生成 null 节点，同时不把 null 节点放到队列里即可。

```java
	// 序列化 - 层序遍历
    private static String serializeByLevel(TreeNode root) {
        if (root == null) {
            return "#!";
        }

        StringBuilder res = new StringBuilder(); // 存储序列化后的结果
        Queue<TreeNode> queue = new LinkedList<>(); // 辅助队列
        queue.offer(root);

        while (!queue.isEmpty()) {
            int currentLevelSize = queue.size();
            for (int i = 0; i < currentLevelSize; i ++) {
                TreeNode node = queue.poll();
                if (node == null) {
                    res.append("#!");
                }
                else { // node != null
                    res.append(node.val).append("!");

                    queue.offer(node.left);
                    queue.offer(node.right);
                }
            }
        }

        return res.toString();
    }
    // 反序列化 - 层序遍历
    private static TreeNode desrializeByLevel(String str) {
        String[] values = str.split("!");
        int index = 0; // values 数组的下标

        Queue<TreeNode> queue = new LinkedList<>(); // 辅助队列

        TreeNode root = generateTreeNodeByString(values[index ++]);
        if (root != null) {
            queue.offer(root);
        }

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            node.left = generateTreeNodeByString(values[index ++]);
            if (node.left != null) {
                queue.offer(node.left);
            }
            node.right = generateTreeNodeByString(values[index ++]);
            if (node.right != null) {
                queue.offer(node.right);
            }
        }

        return root;
    }
    private static TreeNode generateTreeNodeByString(String val) {
        if (val.equals("#")) {
            return null;
        }
        return new TreeNode(Integer.parseInt(val));
    }
```

## CD164. 遍历二叉树的神级方法

【题目链接】：

- NowCoder：[CD164. 遍历二叉树的神级方法](https://www.nowcoder.com/practice/5abcb95fe19d475a989dac3ba53e4635?tpId=101&tqId=33232&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一棵二叉树的头节点 head，完成二叉树的先序、中序和后序遍历。如果二叉树的节点数为 N，则要求时间复杂度为 O(N)，额外空间复杂度为 O(1)。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
输出三行分别表示二叉树的前序，中序和后序遍历。
```

示例1

```
输入
3 1
1 2 3
2 0 0
3 0 0

输出
1 2 3
2 1 3
2 3 1
```

【解题思路】：

本题真正的难点在于对复杂度的要求，尤其是额外空间复杂度为 O(1)的限制。之前的题目已经剖析过如何用递归和非递归的方法实现遍历二叉树，但是很不幸，之前所有的方法虽然常用，但都无法做到额外空间复杂度为 O(1)。

如果完全不用栈结构能完成三种遍历吗？答案是可以。方法是使用二叉树节点中大量指向 null 的指针，本题实际上就是大名鼎鼎的 **Morris 遍历**。

Morris 遍历的实质就是避免用栈结构，而是让下层到上层有指针，具体是通过**让底层节点指向 null 的空闲指针指回上层的某个节点，从而完成下层到上层的移动**。我们知道，二叉树上的很多节点都有大量的空闲指针，比如，某些节点没有右孩子节点，那么这个节点的 right 指针就指向 null，我们称为空闲状态，Morris 遍历正是利用了这些空闲指针。

先看看 Morris 遍历的过程：

假设当前节点为 cur，初始时 cur 就是整棵树的头节点，根据以下标准让 cur 移动：

- 如果 cur 为 null，则过程停止，否则继续下面的过程。
- 如果 cur 没有左子树，则让 cur 向右移动，即令 cur = cur.right。
- 如果 cur 有左子树，则找到 cur 左子树上最右的节点，记为 mostRight。
  - 如果 mostRight 的 right 指针指向 null，则令 mostRight.right = cur，也就是让 mostRight
    的 right 指针指向当前节点，然后让 cur 向左移动，即令 cur = cur.left。
  - 如果 mostRight 的 right 指针指向 cur，则令 mostRight.right = null，也就是让 mostRight
    的 right 指针指向 null，然后让 cur 向右移动，即令 cur = cur.right。

这里先给各位总结下：对于 Morris 遍历，有左子树的节点都可以到达两次，没有左子树的节点都只会到达一次。

举个例子：

![](https://gitee.com/veal98/images/raw/master/img/20210420205458.png)

![](https://gitee.com/veal98/images/raw/master/img/20210420205519.png)

上代码：

```java
// Morris 遍历
private static void morris(TreeNode root) {
    if (root == null) {
        return ;
    }

    TreeNode cur = root;
    TreeNode mostRight = null; // 当前节点左子树上的最右节点

    while (cur != null) {
        // 如果 cur 有左子树
        if (cur.left != null) {
            // 找到 cur 左子树上的最右节点
            mostRight = cur.left;
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            // 如果 mostRight.right 指向 null, 则让其指向 cur
            if (mostRight.right == null) {
                mostRight.right = cur;
                // cur 向左移动
                cur = cur.left;
            }
            // 如果 mostRight.right 指向 cur, 则让其指向 null
            else {
                mostRight.right = null;
                // cur 向右移动
                cur = cur.right;
            }
        }
        // 如果 cur 没有左子树
        else {
            // cur 向右移动
            cur = cur.right;
        }
    }
}
```

**可以根据 Morris 序进一步加工出先序、中序和后序**。

根据 Morris 遍历，加工出先序遍历：

- 对于 cur 只能到达一次的节点（无左子树的节点），cur 到达时直接打印。
- 对于 cur 可以到达两次的节点（有左子树的节点），cur 第一次到达时打印，第二次到达
  时不打印。

根据 Morris 遍历，加工出中序遍历：

- 对于 cur 只能到达一次的节点（无左子树的节点），cur 到达时直接打印。
- 对于 cur 可以到达两次的节点（有左子树的节点），cur 第一次到达时不打印，第二次到
  达时打印。

根据 Morris 遍历，加工出后序遍历：

- 对于 cur 只能到达一次的节点（无左子树的节点），直接跳过，没有打印行为。
- 对于 cur 可以到达两次的任何一个节点（有左子树的节点）X，cur 第一次到达 X 时没有
  打印行为；当第二次到达 X 时，逆序打印 X 左子树的右边界。
- cur 遍历完成后，逆序打印整棵树的右边界。

以图 3-9 来举例说明后序遍历的打印过程，这棵二叉树的 Morris 序为：4、2、1、2、3、4、6、5、6、7。

- 当第二次达到 2 时，逆序打印节点 2 左子树的右边界：1
- 当第二次达到 4 时，逆序打印节点 4 左子树的右边界：3、2
- 当第二次达到 6 时，逆序打印节点 6 左子树的右边界：5

cur 遍历完成后，逆序打印整棵树的右边界：7、6、4

可以看到这个顺序就是后序遍历的顺序。但是我们应该**如何实现逆序打印一棵树的右边界**？因为整个过程的额外空间复杂度要求是 O(1)，所以逆序打印一棵树右边界的过程中，是不能申请额外的数据结构的。为了更好地说明整个过程，下面举一个右边界比较长的例子，如图 3-14 所示：

![](https://gitee.com/veal98/images/raw/master/img/20210420205846.png)

假设 cur 第二次到达了 A，并且要逆序打印节点 A 左子树的右边界，首先将 E.R 指向 null，然后将右边界逆序调整成如图 3-15 所示的样子，**整个过程类似单链表的逆序操作**。

![](https://gitee.com/veal98/images/raw/master/img/20210420205904.png)

这样我们就可以从节点 E 开始，依次通过每个节点的 right 指针逆序打印整个左边界。在打印完 B 后，把右边界再逆序一次，调回来即可。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);

        morrisPre(root);
        System.out.println();
        morrisIn(root);
        System.out.println();
        morrisPos(root);
        System.out.println();
    }

    // Morris 先序遍历
    private static void morrisPre(TreeNode root) {
        if (root == null) {
            return ;
        }

        TreeNode cur = root;
        TreeNode mostRight = null; // 当前节点左子树上的最右节点

        while (cur != null) {
            // 对于 cur 可以到达两次的节点（有左子树的节点），cur 第一次到达时打印，第二次到达时不打印
            if (cur.left != null) {
                mostRight = cur.left;
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }

                if (mostRight.right == null) { // 第一次到达
                    System.out.print(cur.val + " ");
                    mostRight.right = cur;
                    cur = cur.left;
                }
                else { // 第二次到达
                    mostRight.right = null;
                    cur = cur.right;
                }
            }
            // 对于 cur 只能到达一次的节点（无左子树的节点），cur 到达时直接打印。
            else {
                System.out.print(cur.val + " ");
                cur = cur.right;
            }
        }
    }

    // Morris 中序遍历
    private static void morrisIn(TreeNode root) {
        if (root == null) {
            return ;
        }

        TreeNode cur = root;
        TreeNode mostRight = null; // 当前节点左子树上的最右节点

        while (cur != null) {
            // 对于 cur 可以到达两次的节点（有左子树的节点），cur 第一次到达时不打印，第二次到达时打印
            if (cur.left != null) {
                mostRight = cur.left;
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }

                if (mostRight.right == null) { // 第一次到达
                    mostRight.right = cur;
                    cur = cur.left;
                }
                else { // 第二次到达
                    System.out.print(cur.val + " ");
                    mostRight.right = null;
                    cur = cur.right;
                }
            }
            // 对于 cur 只能到达一次的节点（无左子树的节点），cur 到达时直接打印。
            else {
                System.out.print(cur.val + " ");
                cur = cur.right;
            }
        }
    }

    // Morris 后序遍历
    private static void morrisPos(TreeNode root) {
        if (root == null) {
            return ;
        }

        TreeNode cur = root;
        TreeNode mostRight = null; // 当前节点左子树上的最右节点

        while (cur != null) {
            // 对于 cur 可以到达两次的任何一个节点（有左子树的节点）X，cur 第一次到达 X 时没有打印行为；
            // 当第二次到达 X 时，逆序打印 X 左子树的右边界
            if (cur.left != null) {
                mostRight = cur.left;
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }

                if (mostRight.right == null) { // 第一次到达
                    mostRight.right = cur;
                    cur = cur.left;
                }
                else { // 第二次到达
                    mostRight.right = null;
                    printEdge(cur.left); // 打印 cur 左子树的右边界
                    cur = cur.right;
                }
            }
            // 对于 cur 只能到达一次的节点（无左子树的节点），直接跳过，没有打印行为
            else {
                cur = cur.right;
            }
        }
        // cur 遍历完成后，逆序打印整棵树的右边界
        printEdge(root);
    }
    // 逆序打印某个节点的右边界
    private static void printEdge(TreeNode node) {
        TreeNode tail = reverseEdge(node);
        TreeNode cur = tail;
        while (cur != null) {
            System.out.print(cur.val + " ");
            cur = cur.right;
        }
        // 逆序之后记得把树结构恢复原状
        reverseEdge(tail);
    }

    // 逆序从 from 节点开始的右边界
    private static TreeNode reverseEdge(TreeNode from) {
        TreeNode pre = null;
        while (from != null) {
            TreeNode next = from.right; // 防止断链

            from.right = pre;
            pre = from;

            // 进入下一个节点的处理
            from = next;
        }
        return pre;
    }

}
```

## CD165. 在二叉树中找到累加和为指定值的最长路径长度

【题目链接】：

- NowCoder：[CD165. 在二叉树中找到累加和为指定值的最长路径长度](https://www.nowcoder.com/practice/2d35bc3364e3470381bc4eebd9178747?tpId=101&tqId=33233&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一颗二叉树和一个整数 sum，求累加和为 sum 的最长路径长度。路径是指从某个节点往下，每次最多选择一个孩子节点或者不选所形成的节点链。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行四个整数 fa，lch，rch，val，表示 fa 的左儿子为 lch，右儿子为 rch。val 表示 fa 节点的值(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
输出一个整数表示最长链的长度。
```

示例1

```
输入
9 1
1 2 3 -3
2 4 5 3
4 0 0 1
5 8 9 0
8 0 0 1
9 0 0 6
3 6 7 -9
6 0 0 2
7 0 0 1
6

输出
4
```

【解题思路】：

这题和【CD9. 未排序数组中累加和为给定值的最长子数组长度】的思路基本一致，不过有一点需要额外考虑。具体过程如下：

![](https://gitee.com/veal98/images/raw/master/img/20210421224955.png)

另外根据这里题目给出的数据格式，二叉树的构造也需要做一点点的改变

【具体代码】：

```java
package com.smallbeef.Tree;

import java.util.*;

public class CD165 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);
        int sum = sc.nextInt();
        System.out.print(getMaxLength(root, sum));
    }

    private static int getMaxLength(TreeNode root, int sum) {
        Map<Integer, Integer> sumMap = new HashMap<>();
        sumMap.put(0, 0);
        return preOrder(root, sum, 0, 1, 0, sumMap);
    }
    private static int preOrder(TreeNode root, int sum, int preSum, int level,
                                int maxLen, Map<Integer, Integer> sumMap) {
        if (root == null) {
            return maxLen;
        }

        int curSum = preSum + root.val;
        if (!sumMap.containsKey(curSum)) {
            sumMap.put(curSum, level);
        }

        if (sumMap.containsKey(curSum - sum)) {
            maxLen = Math.max(level - sumMap.get(curSum - sum), maxLen);
        }

        maxLen = preOrder(root.left, sum, curSum, level + 1, maxLen, sumMap);
        maxLen = preOrder(root.right, sum, curSum, level + 1, maxLen, sumMap);
        // 回退机制，在计算 cur 节点的左右子树时，如果其 cursum 是第一次出现，也就是 map 中的层数等于当前层数，
        // 那就说明这个累加和 curSum 是在遍历到 cur 时加上去的
        // 所以在我们回退到 cur 的父节点时，需要删除 map 中这条的记录
        if (sumMap.get(curSum) == level) {
            sumMap.remove(curSum);
        }

        return maxLen;
    }

    // 构建二叉树
    private static TreeNode createTree(Scanner sc) {
        String[] values = sc.nextLine().split(" ");
        if (values.length < 3) {
            return null;
        }

        int value = Integer.parseInt(values[3]);
        int left = Integer.parseInt(values[1]);
        int right = Integer.parseInt(values[2]);

        TreeNode root = new TreeNode(value);
        if (left != 0) {
            root.left = createTree(sc);
        }
        if (right != 0) {
            root.right = createTree(sc);
        }

        return root;
    }
}
```

## 树形 DP 问题

树形 dp 套路使用前提：如果题目求解目标是 S，则求解流程可以定成分别以每一个节点作为头节点的子树在目标 S 下的每一个答案，并且最终答案一定在其中。

### CD166. 找到二叉树中的最大搜索二叉子树

【题目链接】：

- NowCoder：[CD166. 找到二叉树中的最大搜索二叉子树](https://www.nowcoder.com/practice/380d49d7f99242709ab4b91c36bf2acc?tpId=101&tqId=33234&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一颗二叉树，已知其中所有节点的值都不一样，找到含有节点最多的搜索二叉子树，**输出该子树总节点的数量**。

搜索二叉树是指对于二叉树的任何一个节点，如果它有儿子，那么左儿子的值应该小于它的值，右儿子的值应该大于它的值。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

ps:节点的编号就是节点的值。
```

输出描述:

```
1 <= n <= 1000000
1 <= fa,lch,rch,root <= n
```

示例1

```
输入
3 2
2 1 3
1 0 0
3 0 0

输出
3
```

【解题思路】：

题目求解目标是：整棵二叉树中的最大搜索二叉子树，这就是我们的目标。那么求解流程可以定成：在整棵二叉树中，求出以每一个节点作为头节点的子树的最大搜索二叉子树（对任何一棵子树都求出答案），并且最终答案（整棵二叉树的最大搜索二叉子树）一定在其中。

**树形 dp 套路第一步**：以某个节点 X 为头节点的子树中，分析答案有哪些可能性，并且这种分析是以 X 的左子树、X 的右子树和 X 整棵树的角度来考虑可能性的。用本题举例。以节点 X 为头节点的子树中，最大的搜索二叉子树只可能是以下三种情况中可能性最大的那种。

- 第一种：X 为头节点的子树中，最大的搜索二叉子树就是 X 的左子树中的最大搜索二叉子树。也就是说，答案可能来自左子树。比如，本例中，当 X 为节点 12 时。
- 第二种：X 为头节点的子树中，最大的搜索二叉子树就是 X 的右子树中的最大搜索二叉子树。也就是说，答案可能来自右子树。比如，本例中，当 X 为节点 6 时。
- 第三种：如果 X 左子树上的最大搜索二叉子树是 X 左子树的全体，X 右子树上的最大搜索二叉子树是 X 右子树的全体，并且 X 的值大于 X 左子树所有节点的最大值，但小于 X 右子树所有节点的最小值，那么 X 为头节点的子树中，最大的搜索二叉子树就是以 X 为头节点的全体。也就是说，答案可能是用 X 连起所有。比如，本例中，当 X 为节点 10 时。

**树形 dp 套路第二步**：根据第一步的可能性分析，列出所有需要的信息。

用本题举例，为了分析第一、二种可能性，需要分别知道左子树和右子树上的最大搜索二叉子树的头部，记为 `leftMaxBSTHead`、`rightMaxBSTHead`，因为要比较大小，所以还需要分别知道左子树和右子树上的最大搜索二叉子树的大小，记为 `leftBSTSize`、`rightBSTSize`，并且有了这些信息还能帮助分析第三种可能性，因为如果知道了 leftMaxBSTHead，并且发现它正好是 X 的左孩子节点，则说明 X左子树上的最大搜索二叉子树是 X 左子树的全体。同理，可以利用 rightMaxBSTHead 来判断 X 右子树上的最大搜索二叉子树是否为 X 右子树的全体。

但是有这些还不够，因为第三种可能性还要求 X 的值大于 X 左子树所有节点的最大值，但小于 X 右子树所有节点的最小值。因此，需要从左子树上取得左子树的最大值 `leftMax`，从右子树上取得右子树的最小值 `rightMin`。汇总一下，为了分析所有的可能性，左树上需要的信息为：leftMaxBSTHead、leftBSTSize、leftMax；右树上需要的信息为：rightMaxBSTHead、rightBSTSize、rightMin。

**树形 dp 套路第三步**：合并第二步的信息，对左树和右树提出同样的要求，并写出信息结构。

以本题举例，左树和右树都需要最大搜索二叉子树的头节点及其大小这两个信息，但是左树只需要最大值，右树只需要最小值，那么合并变成统一要求。信息结构请看如下的 `ReturnType` 类。

```java
// 封装左右子树所需要的信息
class ReturnType {
    private TreeNode maxBSTHead; // 最大搜素树的根节点
    private int maxBSTSize; // 最大搜索树中节点的个数
    private int min; // 搜索树中节点的最小值
    private int max; // 搜索树中节点的最大值

    public ReturnType(TreeNode maxBSTHead, int maxBSTSize, int min, int max) {
        this.maxBSTHead = maxBSTHead;
        this.maxBSTSize = maxBSTSize;
        this.min = min;
        this.max = max;
    }
}
```

**树形 dp 套路第四步**：设计递归函数，递归函数是处理以 X 为头节点的情况下的答案，包括设计递归的 base case，获取左树和右树的所有信息，以及把可能性做整合，并且要返回第三步的信息结构这四个小步骤。本题的实现请看如下的 process 方法。

【具体代码】：

```java
import java.util.Scanner;

public class CD166 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);

        System.out.println(getMaxBst(root));
    }

    // 获取最大搜索子树的节点总数
    private static int getMaxBst(TreeNode root) {
        return process(root).maxBSTSize;
    }
    private static ReturnType process(TreeNode X) {
        // base case
        if (X == null) {
            return new ReturnType(null, 0, Integer.MAX_VALUE, Integer.MIN_VALUE);
        }

        // 获取左子树的信息
        ReturnType lData = process(X.left);
        // 获取右子树的信息
        ReturnType rData = process(X.right);

        int min = Math.min(X.val, Math.min(lData.min, rData.min));
        int max = Math.max(X.val, Math.max(lData.max, rData.max));

        // 最大搜索树在 X 的左子树或者右子树中
        TreeNode maxBSTHead = lData.maxBSTSize >= rData.maxBSTSize ? lData.maxBSTHead : rData.maxBSTHead;
        int maxBSTSize = Math.max(lData.maxBSTSize, rData.maxBSTSize);

        // 最大搜索树的根节点就是 X 本身
        if (lData.maxBSTHead == X.left && rData.maxBSTHead == X.right &&
            X.val > lData.max && X.val < rData.min) {
            maxBSTHead = X;
            maxBSTSize = lData.maxBSTSize + rData.maxBSTSize + 1;
        }

        return new ReturnType(maxBSTHead, maxBSTSize, min, max);
    }

    // 封装左右子树所需要的信息
    static class ReturnType {
        private TreeNode maxBSTHead; // 最大搜素树的根节点
        private int maxBSTSize; // 最大搜索树中节点的个数
        private int min; // 搜索树中节点的最小值
        private int max; // 搜索树中节点的最大值

        public ReturnType(TreeNode maxBSTHead, int maxBSTSize, int min, int max) {
            this.maxBSTHead = maxBSTHead;
            this.maxBSTSize = maxBSTSize;
            this.min = min;
            this.max = max;
        }
    }
}
```

## CD167. 找到二叉树中符合搜索二叉树条件的最大拓扑结构

【题目链接】：

- NowCoder：[CD167. 找到二叉树中符合搜索二叉树条件的最大拓扑结构](https://www.nowcoder.com/practice/e13bceaca5b14860b83cbcc4912c5d4a?tpId=101&tqId=33235&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一颗二叉树，已知所有节点的值都不一样， 返回其中最大的且符合搜索二叉树条件的最大拓扑结构的大小。

拓扑结构是指树上的一个联通块。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

ps:节点的编号就是节点的值。
```

输出描述:

```
输出一个整数表示满足条件的最大拓扑结构的大小。
```

示例1

```
输入
3 2
2 1 3
1 0 0
3 0 0

输出
3
```

【解题思路】：

1）方法一：

整体思路是递归求解：

- 首先获取以 root 为头节点的树中，拓扑结构也以 root 为头节点的最大拓扑结构的节点数
- 然后递归获取 root 左子树的最大拓扑结构的节点数
- 再递归获取 root 右子树的最大拓扑结构的节点数
- 最后返回这三个结果中的最大值就行了

该方法详细见下述的 `bstTopoSize`

那么，**如何获取以 h 为头节点的树中，拓扑结构以 n 为头节点的最大拓扑结构的节点数呢？**

同样也是递归：

- 首先需要判断节点 n 能不能够加入以 h 作为头节点的二叉搜索树
- 然后递归获取以 h 为头节点的树中，拓扑结构以 n.left 为头节点的最大拓扑结构的节点数
- 再递归获取以 h 为头节点的树中，拓扑结构以 n.right 为头节点的最大拓扑结构的节点数
- 最后返回上述左右子数的结果 + 1 就行了

该方法详细见下述的 `maxTopo`

那么问题又来了，**如何判断节点 n 能不能够加入以 h 作为头节点的二叉搜索树中呢？**

这个问题有一种比较容易理解的解法，我们依次考查 h 的孩子节点，根据孩子节点的值从 h 开始按照二叉搜索的方式移动（如果孩子节点的值 < h 的值，则进入 h 的左子树查询；如果孩子节点的值 > h 的值，则进入 h 的右子树查询），如果最后能移动到孩子节点 n上，说明这个孩子节点 n 可以作为这个拓扑的一部分。

该方法详细见下述的 `isBSTNode`

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);

        System.out.println(bstTopoSize(root));
    }

    // 获取 root 为根节点的二叉树上的最大拓扑结构的节点树
    private static int bstTopoSize(TreeNode root) {
        if (root == null) {
            return 0;
        }

        // 获取以 root 为头节点的树中，拓扑结构也以 root 为头节点的最大拓扑结构的节点数
        int max = maxTopo(root, root);
        // 递归获取 root 左子树的最大拓扑结构的节点数
        max = Math.max(bstTopoSize(root.left), max);
        // 递归获取 root 右子树的最大拓扑结构的节点数
        max = Math.max(bstTopoSize(root.right), max);

        return max;
    }

    // 以 h 这个节点为头节点的子树中，拓扑结构以 n 为头节点，求其最大拓扑结构的节点数
    private static int maxTopo(TreeNode h, TreeNode n) {
        if (h != null && n != null && isBSTNode(h, n)) {
            return maxTopo(h, n.left) + maxTopo(h, n.right) + 1;
        }
        return 0;
    }

    // 判断节点 n 能否加入以 h 为 根节点的二叉搜索树中
    private static boolean isBSTNode(TreeNode h, TreeNode n) {
        if (h == null) {
            return false;
        }
        // 如果按照二叉搜索树的方式，h 能够遍历到 n，就说明 n 可以加入
        if (h == n) {
            return true;
        }

        return isBSTNode((h.val > n.val) ? h.left : h.right, n);
    }
}
```

时间复杂度分析：我们把所有的子树（N 个）都找了一次最大拓扑，每找一次，所考查的节点数都可能是 O(N) 个节点，所以方法一的时间复杂度为 O(N^2)

<br>

2）方法二：

## CD169. 找到搜索二叉树中两个错误的节点

【题目链接】：

- NowCoder：[CD169. 找到搜索二叉树中两个错误的节点](https://www.nowcoder.com/practice/9caad175642e4651a175e6993df9d8b2?tpId=101&tqId=33237&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，请按升序输出这两个错误节点的值。(每个节点的值各不相同)

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

ps:节点的编号就是该节点的值。
```

输出描述:

```
请按升序输出这两个错误节点的值。
```

示例1

```
输入
3 1
1 2 3
2 0 0
3 0 0

输出
1 2
```

【解题思路】：

根据**搜索二叉树（二叉排序树）的中序遍历的结果是升序的**这一特点，如果有两个节点位置错了，就一定会出现降序。

如果在中序遍历时节点值出现了两次降序，**第一个错误的节点为第一次降序时较大的节点，第二个错误的节点为第二次降序时较小的节点**。

比如，原来的搜索二叉树在中序遍历时的节点值依次出现 {1,2,3,4,5}，如果因为两个节点位置错了而出现 {1,5,3,4,2}，第一次降序为 5->3，所以第一个错误节点为 5，第二次降序为 4->2，所以第二个错误节点为 2，把 5 和 2 换过来就可以恢复。

【具体代码】：

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);

        TreeNode[] res = getTwoErrorNodes(root);
        System.out.print(res[1].val + " " + res[0].val);

    }

    private static TreeNode[] getTwoErrorNodes(TreeNode root) {
        TreeNode[] res = new TreeNode[2];

        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        TreeNode pre = null; // 中序遍历的前驱节点
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            else {
                cur = stack.pop();

                if (pre != null && pre.val > cur.val) {
                    res[0] = (res[0] == null ? pre : res[0]);
                    res[1] = cur;
                }
                pre = cur;

                cur = cur.right;
            }
        }

        return res;
    }
}
```

