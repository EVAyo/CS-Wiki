# 二叉树问题

---

## CD161. 实现二叉树先序，中序和后序遍历

【题目链接】：

- NowCoder：[CD161. 实现二叉树先序，中序和后序遍历](https://www.nowcoder.com/practice/566f7f9d68c24691aa5abd8abefa798c?tpId=101&tqId=33229&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

分别按照二叉树先序，中序和后序打印所有的节点。

输入描述:

第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

输出描述:

输出三行，分别表示二叉树的先序，中序和后序。

示例1

```
输入
3 1
1 2 3
2 0 0
3 0 0

输出
1 2 3
2 1 3
2 3 1
```

【解题思路】：

下面代码给出了遍历的递归和非递归版本。另外如何构建二叉树也需要注意。

【具体代码】：

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行数据没啥用
        TreeNode root = createTree(sc);

        List<Integer> preOrderList = preOrderUnRecur(root);
        for (int i : preOrderList) {
            System.out.print(i + " ");
        }
        System.out.println();

        List<Integer> inOrderList = inOrderUnRecur(root);
        for (int i : inOrderList) {
            System.out.print(i + " ");
        }
        System.out.println();

        List<Integer> postOrderList = postOrderUnRecur(root);
        for (int i : postOrderList) {
            System.out.print(i + " ");
        }
        System.out.println();
    }

    // 先序遍历 - 递归
    private static List<Integer> preOrderRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>(); // 存储遍历结果
        if (root == null) {
            return res;
        }

        res.add(root.val);
        preOrderRecur(root.left);
        preOrderRecur(root.right);

        return res;
    }
    // 中序遍历 - 递归
    private static List<Integer> inOrderRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        inOrderRecur(root.left);
        res.add(root.val);
        inOrderRecur(root.right);

        return res;
    }
    // 后序遍历 - 递归
    private static List<Integer> postOrderRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        postOrderRecur(root.left);
        postOrderRecur(root.right);
        res.add(root.val);

        return res;
    }

    // 先序遍历 - 非递归
    private static List<Integer> preOrderUnRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                res.add(cur.val);
                cur = cur.left;
            }
            else {
                cur = stack.pop();
                cur = cur.right;
            }
        }

        return res;
    }
    // 中序遍历 - 非递归
    private static List<Integer> inOrderUnRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            else {
                cur = stack.pop();
                res.add(cur.val);
                cur = cur.right;
            }
        }

        return res;
    }
    // 后序遍历 - 非递归
    private static List<Integer> postOrderUnRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        TreeNode recently = null; // 最近访问过的节点
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            else {
                // 获取栈顶元素
                cur = stack.peek();
                // 右孩子存在且未被访问过
                if (cur.right != null && recently != cur.right) {
                    cur = cur.right;
                    stack.push(cur);
                    cur = cur.left;
                }
                // 右孩子不存在或者已被访问过或者右孩子不存在
                else {
                    cur = stack.pop();
                    res.add(cur.val);
                    recently = cur; // 设为最近访问节点
                    cur = null; // cur 重置(即继续获取栈顶元素并对其进行判断)
                }
            }

        }

        return res;
    }

    // 构造二叉树
    private static TreeNode createTree(Scanner sc) {
        String[] values = sc.nextLine().split(" ");
        if (values.length < 3) {
            return null;
        }

        int value = Integer.parseInt(values[0]);
        int left = Integer.parseInt(values[1]);
        int right = Integer.parseInt(values[2]);

        TreeNode root = new TreeNode(value);
        if (left != 0) {
            root.left = createTree(sc);
        }
        if (right != 0) {
            root.right = createTree(sc);
        }

        return root;
    }

    // 定义二叉树
    static class TreeNode {
        private int val;
        private TreeNode left;
        private TreeNode right;

        public TreeNode (int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }
}
```

## LC102/SO32. 层次遍历

【题目链接】：

- LeetCode：[102. 二叉树的层序遍历 — Medium](https://leetcode-cn.com/problems/binary-tree-level-order-traversal) 
- 剑指 Offer：[32 - II. 从上到下打印二叉树 II — Easy](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

【题目描述】：

给你一个二叉树，请你返回其按 层序遍历 得到的节点值（即逐层地，从左到右访问所有节点）。

示例：

```
二叉树：[3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7

返回其层序遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
```

【解题思路】：

利用队列先进先出的特性（广度优先搜索）

【具体代码】：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        
        if(root == null)
            return res;
        
        queue.offer(root); // 队列尾部添加元素。offer 方法在超出队列界限的时候直接返回 false
        
        while(!queue.isEmpty()){
            List<Integer> level = new ArrayList<Integer>(); // 存储每个层的节点
            int currentLevelSize = queue.size();
            for (int i = 0; i < currentLevelSize; i ++){
                TreeNode node = queue.poll();
                level.add(node.val);
                if(node.left != null)
                    queue.offer(node.left);
                if(node.right != null)
                    queue.offer(node.right);
            }
            
            res.add(level);  
        }
        
        return res;
    }
}
```

## CD162. 打印二叉树的边界节点

【题目链接】：

- NowCoder：[CD161. 实现二叉树先序，中序和后序遍历](https://www.nowcoder.com/practice/566f7f9d68c24691aa5abd8abefa798c?tpId=101&tqId=33229&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一颗二叉树的根节点 root，按照如下两种标准分别实现二叉树的边界节点的逆时针打印。

标准一：

1，根节点为边界节点。

2，叶节点为边界节点。

3，如果节点在其所在的层中是最左的或最右的，那么该节点也是边界节点。

标准二：

1，根节点为边界节点。

2，叶节点为边界节点。

3，树左边界延伸下去的路径为边界节点。

4，树右边界延伸下去的路径为边界节点。

ps: 具体请对照样例

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
输出两行整数分别表示按两种标准的边界节点。
```

示例 1:

<img src="https://gitee.com/veal98/images/raw/master/img/20210418153718.png" style="zoom:80%;" />

```
输入
16 1
1 2 3
2 0 4
4 7 8
7 0 0
8 0 11
11 13 14
13 0 0
14 0 0
3 5 6
5 9 10
10 0 0
9 12 0
12 15 16
15 0 0
16 0 0
6 0 0

输出
1 2 4 7 11 13 14 15 16 12 10 6 3
1 2 4 7 13 14 15 16 10 6 3
```

【解题思路】：

对于标准一：

![](https://gitee.com/veal98/images/raw/master/img/20210418154232.png)

对于标准二：

![](https://gitee.com/veal98/images/raw/master/img/20210418154416.png)

【具体代码】：

```java

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行不重要
        TreeNode root = createTree(sc);

        List<Integer> edge1 = printEdge1(root);
        for (int i : edge1) {
            System.out.print(i + " ");
        }

        System.out.println();

        List<TreeNode> edge2 = new ArrayList<>();
        printEdge2(root, edge2);
        for (TreeNode node : edge2) {
            System.out.print(node.val + " ");
        }
    }

    // 按照标准一输出边界
    private static List<Integer> printEdge1(TreeNode root) {
        List<Integer> res = new ArrayList<>(); // 存储结果
        if (root == null) {
            return res;
        }

        int height = getHeight(root); // 获取二叉树高度
        // 存储每层的最左和最右节点
        // edgeMap[i][0] 表示第 i 层的最左节点
        // edgeMap[i][1] 表示第 i 层的最右节点
        TreeNode[][] edgeMap = new TreeNode[height][2];
        setEdgeMap(root, 0, edgeMap);

        // 打印左边界
        for (int i = 0; i < edgeMap.length; i ++) {
            res.add(edgeMap[i][0].val);
        }

        // 打印既不是左边界也不是右边界的叶子节点
        List<TreeNode> leafNotInMapList = new ArrayList<>();
        getLeafNotInMap(root, 0, edgeMap, leafNotInMapList);
        for (TreeNode node : leafNotInMapList) {
            res.add(node.val);
        }

        // 打印右边界(自下向上),但不是左边界的节点
        for (int i = edgeMap.length-1; i >= 0; i --) {
            if (edgeMap[i][0] != edgeMap[i][1]) {
                res.add(edgeMap[i][1].val);
            }
        }

        return res;
    }

    // 递归获取二叉树高度
    private static int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {
            return 1;
        }

        int leftHeight = getHeight(root.left);
        int rightHeight = getHeight(root.right);

        return Math.max(leftHeight, rightHeight) + 1;
    }

    /**
     * 递归存储每层的最左和最右节点
     * @param root
     * @param h 第几层
     * @param edgeMap
     */
    private static void setEdgeMap(TreeNode root, int h, TreeNode[][] edgeMap) {
        if (root == null) {
            return ;
        }

        edgeMap[h][0] = (edgeMap[h][0] == null) ? root : edgeMap[h][0];
        edgeMap[h][1] = root;

        setEdgeMap(root.left, h + 1, edgeMap);
        setEdgeMap(root.right, h + 1, edgeMap);
    }

    // 获取既不是左边界也不是右边界的叶子节点
    private static void getLeafNotInMap(TreeNode root, int h, TreeNode[][] edgeMap, List<TreeNode> leafNotInMapList) {
        if (root == null) {
            return ;
        }

        if (root.left == null && root.right == null &&
            root != edgeMap[h][0] && root != edgeMap[h][1]) {
            leafNotInMapList.add(root);
        }

        getLeafNotInMap(root.left, h + 1, edgeMap, leafNotInMapList);
        getLeafNotInMap(root.right, h + 1, edgeMap, leafNotInMapList);

    }


    // 按照标准二输出边界
    private static void printEdge2(TreeNode root, List<TreeNode> edgeList) {
        if (root == null) {
            return ;
        }

        edgeList.add(root); // 头节点符合标准二的要求

        if (root.left != null && root.right != null) {
            // 打印左边界的延伸路径，以及 root 左子树上所有的叶节点
            List<TreeNode> leftEdgeList = new ArrayList<>();
            getLeftEdge(root.left, true, leftEdgeList);
            for (TreeNode node : leftEdgeList) {
                edgeList.add(node);
            }
            // 打印右边界的延伸路径，以及 root 右子树上所有的叶节点
            List<TreeNode> rightEdgeList = new ArrayList<>();
            getRightEdge(root.right, true, rightEdgeList);
            for (TreeNode node : rightEdgeList) {
                edgeList.add(node);
            }
        }
        else {
            printEdge2((root.left != null) ? root.left : root.right, edgeList);
        }
    }

    private static void getLeftEdge(TreeNode root, boolean print, List<TreeNode> leftEdgeList) {
        if (root == null) {
            return ;
        }

        // 叶子节点
        if (print == true || (root.left == null && root.right == null)) {
            leftEdgeList.add(root);
        }

        getLeftEdge(root.left, print, leftEdgeList);
        getLeftEdge(root.right, (print == true && root.left == null) ? true : false, leftEdgeList);
    }

    private static void getRightEdge(TreeNode root, boolean print, List<TreeNode> rightEdgeList) {
        if (root == null) {
            return ;
        }

        getRightEdge(root.left, (print == true && root.right == null) ? true : false, rightEdgeList);
        getRightEdge(root.right, print, rightEdgeList);

        // 叶子节点
        if (print || (root.left == null && root.right == null)) {
            rightEdgeList.add(root);
        }
    }

    // 构造二叉树
    private static TreeNode createTree(Scanner sc) {
        String[] values = sc.nextLine().split(" ");
        if (values.length < 3) {
            return null;
        }

        int value = Integer.parseInt(values[0]);
        int left = Integer.parseInt(values[1]);
        int right = Integer.parseInt(values[2]);

        TreeNode root = new TreeNode(value);
        if (left != 0) {
            root.left = createTree(sc);
        }
        if (right != 0) {
            root.right = createTree(sc);
        }

        return root;
    }

    // 定义二叉树
    static class TreeNode {
        private int val;
        private TreeNode left;
        private TreeNode right;

        public TreeNode (int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }
}
```

## CD163/LC297/SO37. 二叉树的序列化和反序列化

【题目链接】：

- NowCoder：[CD163. 二叉树的序列化和反序列化](https://www.nowcoder.com/practice/d6425eab86fc402085f9fafc0db97cc2?tpId=101&tqId=33231&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)
- 剑指 Offer ：[剑指 Offer 37. 序列化二叉树 — Hard](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)
- LeetCode：[297. 二叉树的序列化与反序列化 — Hard](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)
- 牛客题霸.：[序列化二叉树](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=117&tqId=37782&companyId=134&rp=1&ru=%2Fcompany%2Fhome%2Fcode%2F134&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey)

【题目描述】：

二叉树被记录为文件的过程叫作二叉树的序列化，通过文件内容重建原来二叉树的过程叫作二叉树的反序列化，给定一颗二叉树，请将该二叉树先序序列化和层序序列化。

假设序列化的结果字符串为 str，初始时 str = ""，遍历二叉树时，遇到 null 节点，则在 str 的末尾加上 "#!"，否则加上"当前的节点值!"。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
输出两行分别表示该二叉树的先序序列化和层序序列化
```

示例1

```
输入
2 1
1 2 0
2 0 0

输出
1!2!#!#!#!
1!2!#!#!#!
```

【解题思路】：

1）利用**先序遍历**来序列化和反序列化（这种比较好理解）

先序遍历的反序列化其实就是重做先序遍历，遇到 "#" 就生成 null 节点，结束生成后续子树的过程。

```java
	// 序列化 - 先序遍历
    private static String serializeByPre(TreeNode root) {
        if (root == null) {
            return "#!";
        }

        StringBuilder res = new StringBuilder(); // 存储序列化后的结果
        res.append(root.val).append("!");

        res.append(serializeByPre(root.left));
        res.append(serializeByPre(root.right));

        return res.toString();
    }
    // 反序列化 - 先序遍历
    private static TreeNode desrializeByPre(String str) {
        // 拆分字符串并一一入队
        String[] values = str.split("!");
        Queue<String> queue = new LinkedList<>();
        for (int i = 0; i < values.length; i ++) {
            queue.offer(values[i]);
        }

        return reconPreOrder(queue);
    }
    private static TreeNode reconPreOrder(Queue<String> queue) {
        // 每次弹出一个节点进行判断
        String value = queue.poll();
        if (value.equals("#")) { // 当前节点为空
            return null;
        }
        // 总是根据首位元素确定当前子树的根
        TreeNode root = new TreeNode(Integer.parseInt(value));
        root.left = reconPreOrder(queue);
        root.right = reconPreOrder(queue);

        return root;
    }
```

2）利用**层次遍历**来序列化和反序列化


与根据先序遍历的反序列化过程一样，根据层遍历的反序列化是重做层遍历，遇到 "#" 就生成 null 节点，同时不把 null 节点放到队列里即可。

```java
	// 序列化 - 层序遍历
    private static String serializeByLevel(TreeNode root) {
        if (root == null) {
            return "#!";
        }

        StringBuilder res = new StringBuilder(); // 存储序列化后的结果
        Queue<TreeNode> queue = new LinkedList<>(); // 辅助队列
        queue.offer(root);

        while (!queue.isEmpty()) {
            int currentLevelSize = queue.size();
            for (int i = 0; i < currentLevelSize; i ++) {
                TreeNode node = queue.poll();
                if (node == null) {
                    res.append("#!");
                }
                else { // node != null
                    res.append(node.val).append("!");

                    queue.offer(node.left);
                    queue.offer(node.right);
                }
            }
        }

        return res.toString();
    }
    // 反序列化 - 层序遍历
    private static TreeNode desrializeByLevel(String str) {
        String[] values = str.split("!");
        int index = 0; // values 数组的下标

        Queue<TreeNode> queue = new LinkedList<>(); // 辅助队列

        TreeNode root = generateTreeNodeByString(values[index ++]);
        if (root != null) {
            queue.offer(root);
        }

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            node.left = generateTreeNodeByString(values[index ++]);
            if (node.left != null) {
                queue.offer(node.left);
            }
            node.right = generateTreeNodeByString(values[index ++]);
            if (node.right != null) {
                queue.offer(node.right);
            }
        }

        return root;
    }
    private static TreeNode generateTreeNodeByString(String val) {
        if (val.equals("#")) {
            return null;
        }
        return new TreeNode(Integer.parseInt(val));
    }
```

## CD164. 遍历二叉树的神级方法

【题目链接】：

- NowCoder：[CD164. 遍历二叉树的神级方法](https://www.nowcoder.com/practice/5abcb95fe19d475a989dac3ba53e4635?tpId=101&tqId=33232&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一棵二叉树的头节点 head，完成二叉树的先序、中序和后序遍历。如果二叉树的节点数为 N，则要求时间复杂度为 O(N)，额外空间复杂度为 O(1)。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
输出三行分别表示二叉树的前序，中序和后序遍历。
```

示例1

```
输入
3 1
1 2 3
2 0 0
3 0 0

输出
1 2 3
2 1 3
2 3 1
```

【解题思路】：

本题真正的难点在于对复杂度的要求，尤其是额外空间复杂度为 O(1)的限制。之前的题目已经剖析过如何用递归和非递归的方法实现遍历二叉树，但是很不幸，之前所有的方法虽然常用，但都无法做到额外空间复杂度为 O(1)。

如果完全不用栈结构能完成三种遍历吗？答案是可以。方法是使用二叉树节点中大量指向 null 的指针，本题实际上就是大名鼎鼎的 **Morris 遍历**。

Morris 遍历的实质就是避免用栈结构，而是让下层到上层有指针，具体是通过**让底层节点指向 null 的空闲指针指回上层的某个节点，从而完成下层到上层的移动**。我们知道，二叉树上的很多节点都有大量的空闲指针，比如，某些节点没有右孩子节点，那么这个节点的 right 指针就指向 null，我们称为空闲状态，Morris 遍历正是利用了这些空闲指针。

先看看 Morris 遍历的过程：

假设当前节点为 cur，初始时 cur 就是整棵树的头节点，根据以下标准让 cur 移动：

- 如果 cur 为 null，则过程停止，否则继续下面的过程。
- 如果 cur 没有左子树，则让 cur 向右移动，即令 cur = cur.right。
- 如果 cur 有左子树，则找到 cur 左子树上最右的节点，记为 mostRight。
  - 如果 mostRight 的 right 指针指向 null，则令 mostRight.right = cur，也就是让 mostRight
    的 right 指针指向当前节点，然后让 cur 向左移动，即令 cur = cur.left。
  - 如果 mostRight 的 right 指针指向 cur，则令 mostRight.right = null，也就是让 mostRight
    的 right 指针指向 null，然后让 cur 向右移动，即令 cur = cur.right。

这里先给各位总结下：对于 Morris 遍历，有左子树的节点都可以到达两次，没有左子树的节点都只会到达一次。

举个例子：

![](https://gitee.com/veal98/images/raw/master/img/20210420205458.png)

![](https://gitee.com/veal98/images/raw/master/img/20210420205519.png)

上代码：

```java
// Morris 遍历
private static void morris(TreeNode root) {
    if (root == null) {
        return ;
    }

    TreeNode cur = root;
    TreeNode mostRight = null; // 当前节点左子树上的最右节点

    while (cur != null) {
        // 如果 cur 有左子树
        if (cur.left != null) {
            // 找到 cur 左子树上的最右节点
            mostRight = cur.left;
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            // 如果 mostRight.right 指向 null, 则让其指向 cur
            if (mostRight.right == null) {
                mostRight.right = cur;
                // cur 向左移动
                cur = cur.left;
            }
            // 如果 mostRight.right 指向 cur, 则让其指向 null
            else {
                mostRight.right = null;
                // cur 向右移动
                cur = cur.right;
            }
        }
        // 如果 cur 没有左子树
        else {
            // cur 向右移动
            cur = cur.right;
        }
    }
}
```

**可以根据 Morris 序进一步加工出先序、中序和后序**。

根据 Morris 遍历，加工出先序遍历：

- 对于 cur 只能到达一次的节点（无左子树的节点），cur 到达时直接打印。
- 对于 cur 可以到达两次的节点（有左子树的节点），cur 第一次到达时打印，第二次到达
  时不打印。

根据 Morris 遍历，加工出中序遍历：

- 对于 cur 只能到达一次的节点（无左子树的节点），cur 到达时直接打印。
- 对于 cur 可以到达两次的节点（有左子树的节点），cur 第一次到达时不打印，第二次到
  达时打印。

根据 Morris 遍历，加工出后序遍历：

- 对于 cur 只能到达一次的节点（无左子树的节点），直接跳过，没有打印行为。
- 对于 cur 可以到达两次的任何一个节点（有左子树的节点）X，cur 第一次到达 X 时没有
  打印行为；当第二次到达 X 时，逆序打印 X 左子树的右边界。
- cur 遍历完成后，逆序打印整棵树的右边界。

以图 3-9 来举例说明后序遍历的打印过程，这棵二叉树的 Morris 序为：4、2、1、2、3、4、6、5、6、7。

- 当第二次达到 2 时，逆序打印节点 2 左子树的右边界：1
- 当第二次达到 4 时，逆序打印节点 4 左子树的右边界：3、2
- 当第二次达到 6 时，逆序打印节点 6 左子树的右边界：5

cur 遍历完成后，逆序打印整棵树的右边界：7、6、4

可以看到这个顺序就是后序遍历的顺序。但是我们应该**如何实现逆序打印一棵树的右边界**？因为整个过程的额外空间复杂度要求是 O(1)，所以逆序打印一棵树右边界的过程中，是不能申请额外的数据结构的。为了更好地说明整个过程，下面举一个右边界比较长的例子，如图 3-14 所示：

![](https://gitee.com/veal98/images/raw/master/img/20210420205846.png)

假设 cur 第二次到达了 A，并且要逆序打印节点 A 左子树的右边界，首先将 E.R 指向 null，然后将右边界逆序调整成如图 3-15 所示的样子，**整个过程类似单链表的逆序操作**。

![](https://gitee.com/veal98/images/raw/master/img/20210420205904.png)

这样我们就可以从节点 E 开始，依次通过每个节点的 right 指针逆序打印整个左边界。在打印完 B 后，把右边界再逆序一次，调回来即可。

【具体代码】：

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);

        morrisPre(root);
        System.out.println();
        morrisIn(root);
        System.out.println();
        morrisPos(root);
        System.out.println();
    }

    // Morris 先序遍历
    private static void morrisPre(TreeNode root) {
        if (root == null) {
            return ;
        }

        TreeNode cur = root;
        TreeNode mostRight = null; // 当前节点左子树上的最右节点

        while (cur != null) {
            // 对于 cur 可以到达两次的节点（有左子树的节点），cur 第一次到达时打印，第二次到达时不打印
            if (cur.left != null) {
                mostRight = cur.left;
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }

                if (mostRight.right == null) { // 第一次到达
                    System.out.print(cur.val + " ");
                    mostRight.right = cur;
                    cur = cur.left;
                }
                else { // 第二次到达
                    mostRight.right = null;
                    cur = cur.right;
                }
            }
            // 对于 cur 只能到达一次的节点（无左子树的节点），cur 到达时直接打印。
            else {
                System.out.print(cur.val + " ");
                cur = cur.right;
            }
        }
    }

    // Morris 中序遍历
    private static void morrisIn(TreeNode root) {
        if (root == null) {
            return ;
        }

        TreeNode cur = root;
        TreeNode mostRight = null; // 当前节点左子树上的最右节点

        while (cur != null) {
            // 对于 cur 可以到达两次的节点（有左子树的节点），cur 第一次到达时不打印，第二次到达时打印
            if (cur.left != null) {
                mostRight = cur.left;
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }

                if (mostRight.right == null) { // 第一次到达
                    mostRight.right = cur;
                    cur = cur.left;
                }
                else { // 第二次到达
                    System.out.print(cur.val + " ");
                    mostRight.right = null;
                    cur = cur.right;
                }
            }
            // 对于 cur 只能到达一次的节点（无左子树的节点），cur 到达时直接打印。
            else {
                System.out.print(cur.val + " ");
                cur = cur.right;
            }
        }
    }

    // Morris 后序遍历
    private static void morrisPos(TreeNode root) {
        if (root == null) {
            return ;
        }

        TreeNode cur = root;
        TreeNode mostRight = null; // 当前节点左子树上的最右节点

        while (cur != null) {
            // 对于 cur 可以到达两次的任何一个节点（有左子树的节点）X，cur 第一次到达 X 时没有打印行为；
            // 当第二次到达 X 时，逆序打印 X 左子树的右边界
            if (cur.left != null) {
                mostRight = cur.left;
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }

                if (mostRight.right == null) { // 第一次到达
                    mostRight.right = cur;
                    cur = cur.left;
                }
                else { // 第二次到达
                    mostRight.right = null;
                    printEdge(cur.left); // 打印 cur 左子树的右边界
                    cur = cur.right;
                }
            }
            // 对于 cur 只能到达一次的节点（无左子树的节点），直接跳过，没有打印行为
            else {
                cur = cur.right;
            }
        }
        // cur 遍历完成后，逆序打印整棵树的右边界
        printEdge(root);
    }
    // 逆序打印某个节点的右边界
    private static void printEdge(TreeNode node) {
        TreeNode tail = reverseEdge(node);
        TreeNode cur = tail;
        while (cur != null) {
            System.out.print(cur.val + " ");
            cur = cur.right;
        }
        // 逆序之后记得把树结构恢复原状
        reverseEdge(tail);
    }

    // 逆序从 from 节点开始的右边界
    private static TreeNode reverseEdge(TreeNode from) {
        TreeNode pre = null;
        while (from != null) {
            TreeNode next = from.right; // 防止断链

            from.right = pre;
            pre = from;

            // 进入下一个节点的处理
            from = next;
        }
        return pre;
    }

    // 构建二叉树
    private static TreeNode createTree(Scanner sc) {
        String[] values = sc.nextLine().split(" ");
        if (values.length < 3) {
            return null;
        }

        int value = Integer.parseInt(values[0]);
        int left = Integer.parseInt(values[1]);
        int right = Integer.parseInt(values[2]);

        TreeNode root = new TreeNode(value);
        if (left != 0) {
            root.left = createTree(sc);
        }
        if (right != 0) {
            root.right = createTree(sc);
        }

        return root;
    }

    // 定义二叉树
    static class TreeNode {
        private int val;
        private TreeNode left;
        private TreeNode right;

        public TreeNode (int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }
}
```

## CD165. 在二叉树中找到累加和为指定值的最长路径长度

【题目链接】：

- NowCoder：[CD165. 在二叉树中找到累加和为指定值的最长路径长度](https://www.nowcoder.com/practice/2d35bc3364e3470381bc4eebd9178747?tpId=101&tqId=33233&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一颗二叉树和一个整数 sum，求累加和为 sum 的最长路径长度。路径是指从某个节点往下，每次最多选择一个孩子节点或者不选所形成的节点链。

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行四个整数 fa，lch，rch，val，表示 fa 的左儿子为 lch，右儿子为 rch。val 表示 fa 节点的值(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
输出一个整数表示最长链的长度。
```

示例1

```
输入
9 1
1 2 3 -3
2 4 5 3
4 0 0 1
5 8 9 0
8 0 0 1
9 0 0 6
3 6 7 -9
6 0 0 2
7 0 0 1
6

输出
4
```

【解题思路】：

这题和【CD9. 未排序数组中累加和为给定值的最长子数组长度】的思路基本一致，不过有一点需要额外考虑。具体过程如下：

![](https://gitee.com/veal98/images/raw/master/img/20210421224955.png)

另外根据这里题目给出的数据格式，二叉树的构造也需要做一点点的改变

【具体代码】：

```java
package com.smallbeef.Tree;

import java.util.*;

public class CD165 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行没啥用
        TreeNode root = createTree(sc);
        int sum = sc.nextInt();
        System.out.print(getMaxLength(root, sum));
    }

    private static int getMaxLength(TreeNode root, int sum) {
        Map<Integer, Integer> sumMap = new HashMap<>();
        sumMap.put(0, 0);
        return preOrder(root, sum, 0, 1, 0, sumMap);
    }
    private static int preOrder(TreeNode root, int sum, int preSum, int level,
                                int maxLen, Map<Integer, Integer> sumMap) {
        if (root == null) {
            return maxLen;
        }

        int curSum = preSum + root.val;
        if (!sumMap.containsKey(curSum)) {
            sumMap.put(curSum, level);
        }

        if (sumMap.containsKey(curSum - sum)) {
            maxLen = Math.max(level - sumMap.get(curSum - sum), maxLen);
        }

        maxLen = preOrder(root.left, sum, curSum, level + 1, maxLen, sumMap);
        maxLen = preOrder(root.right, sum, curSum, level + 1, maxLen, sumMap);
        // 回退机制，在计算 cur 节点的左右子树时，如果其 cursum 是第一次出现，也就是 map 中的层数等于当前层数，
        // 那就说明这个累加和 curSum 是在遍历到 cur 时加上去的
        // 所以在我们回退到 cur 的父节点时，需要删除 map 中这条的记录
        if (sumMap.get(curSum) == level) {
            sumMap.remove(curSum);
        }

        return maxLen;
    }

    // 构建二叉树
    private static TreeNode createTree(Scanner sc) {
        String[] values = sc.nextLine().split(" ");
        if (values.length < 3) {
            return null;
        }

        int value = Integer.parseInt(values[3]);
        int left = Integer.parseInt(values[1]);
        int right = Integer.parseInt(values[2]);

        TreeNode root = new TreeNode(value);
        if (left != 0) {
            root.left = createTree(sc);
        }
        if (right != 0) {
            root.right = createTree(sc);
        }

        return root;
    }

    // 定义二叉树
    static class TreeNode {
        private int val;
        private TreeNode left;
        private TreeNode right;

        public TreeNode (int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }
}
```

