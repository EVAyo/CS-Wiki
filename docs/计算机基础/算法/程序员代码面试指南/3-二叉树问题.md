# 二叉树问题

---

## CD161. 实现二叉树先序，中序和后序遍历

【题目链接】：

- NowCoder：[CD161. 实现二叉树先序，中序和后序遍历](https://www.nowcoder.com/practice/566f7f9d68c24691aa5abd8abefa798c?tpId=101&tqId=33229&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

分别按照二叉树先序，中序和后序打印所有的节点。

输入描述:

第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。

以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)

输出描述:

输出三行，分别表示二叉树的先序，中序和后序。

示例1

```
输入
3 1
1 2 3
2 0 0
3 0 0

输出
1 2 3
2 1 3
2 3 1
```

【解题思路】：

下面代码给出了遍历的递归和非递归版本。另外如何构建二叉树也需要注意。

【具体代码】：

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行数据没啥用
        TreeNode root = createTree(sc);

        List<Integer> preOrderList = preOrderUnRecur(root);
        for (int i : preOrderList) {
            System.out.print(i + " ");
        }
        System.out.println();

        List<Integer> inOrderList = inOrderUnRecur(root);
        for (int i : inOrderList) {
            System.out.print(i + " ");
        }
        System.out.println();

        List<Integer> postOrderList = postOrderUnRecur(root);
        for (int i : postOrderList) {
            System.out.print(i + " ");
        }
        System.out.println();
    }

    // 先序遍历 - 递归
    private static List<Integer> preOrderRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>(); // 存储遍历结果
        if (root == null) {
            return res;
        }

        res.add(root.val);
        preOrderRecur(root.left);
        preOrderRecur(root.right);

        return res;
    }
    // 中序遍历 - 递归
    private static List<Integer> inOrderRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        inOrderRecur(root.left);
        res.add(root.val);
        inOrderRecur(root.right);

        return res;
    }
    // 后序遍历 - 递归
    private static List<Integer> postOrderRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        postOrderRecur(root.left);
        postOrderRecur(root.right);
        res.add(root.val);

        return res;
    }

    // 先序遍历 - 非递归
    private static List<Integer> preOrderUnRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                res.add(cur.val);
                cur = cur.left;
            }
            else {
                cur = stack.pop();
                cur = cur.right;
            }
        }

        return res;
    }
    // 中序遍历 - 非递归
    private static List<Integer> inOrderUnRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            else {
                cur = stack.pop();
                res.add(cur.val);
                cur = cur.right;
            }
        }

        return res;
    }
    // 后序遍历 - 非递归
    private static List<Integer> postOrderUnRecur(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Stack<TreeNode> stack = new Stack<>(); // 辅助栈
        TreeNode cur = root; // 工作指针
        TreeNode recently = null; // 最近访问过的节点
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            else {
                // 获取栈顶元素
                cur = stack.peek();
                // 右孩子存在且未被访问过
                if (cur.right != null && recently != cur.right) {
                    cur = cur.right;
                    stack.push(cur);
                    cur = cur.left;
                }
                // 右孩子不存在或者已被访问过或者右孩子不存在
                else {
                    cur = stack.pop();
                    res.add(cur.val);
                    recently = cur; // 设为最近访问节点
                    cur = null; // cur 重置(即继续获取栈顶元素并对其进行判断)
                }
            }

        }

        return res;
    }

    // 构造二叉树
    private static TreeNode createTree(Scanner sc) {
        String[] values = sc.nextLine().split(" ");
        if (values.length < 3) {
            return null;
        }

        int value = Integer.parseInt(values[0]);
        int left = Integer.parseInt(values[1]);
        int right = Integer.parseInt(values[2]);

        TreeNode root = new TreeNode(value);
        if (left != 0) {
            root.left = createTree(sc);
        }
        if (right != 0) {
            root.right = createTree(sc);
        }

        return root;
    }

    // 定义二叉树
    static class TreeNode {
        private int val;
        private TreeNode left;
        private TreeNode right;

        public TreeNode (int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }
}
```

## LC102/SO32. 层次遍历

【题目链接】：

- LeetCode：[102. 二叉树的层序遍历 — Medium](https://leetcode-cn.com/problems/binary-tree-level-order-traversal) 
- 剑指 Offer：[32 - II. 从上到下打印二叉树 II — Easy](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

【题目描述】：

给你一个二叉树，请你返回其按 层序遍历 得到的节点值（即逐层地，从左到右访问所有节点）。

示例：

```
二叉树：[3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7

返回其层序遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
```

【解题思路】：

利用队列先进先出的特性（广度优先搜索）

【具体代码】：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        
        if(root == null)
            return res;
        
        queue.offer(root); // 队列尾部添加元素。offer 方法在超出队列界限的时候直接返回 false
        
        while(!queue.isEmpty()){
            List<Integer> level = new ArrayList<Integer>(); // 存储每个层的节点
            int currentLevelSize = queue.size();
            for (int i = 1; i <= currentLevelSize; ++i){
                TreeNode node = queue.poll();
                level.add(node.val);
                if(node.left != null)
                    queue.offer(node.left);
                if(node.right != null)
                    queue.offer(node.right);
            }
            
            res.add(level);  
        }
        
        return res;
    }
}
```

## CD162. 打印二叉树的边界节点

【题目链接】：

- NowCoder：[CD161. 实现二叉树先序，中序和后序遍历](https://www.nowcoder.com/practice/566f7f9d68c24691aa5abd8abefa798c?tpId=101&tqId=33229&rp=1&ru=%2Fta%2Fprogrammer-code-interview-guide&qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking&tab=answerKey)

【题目描述】：

给定一颗二叉树的根节点 root，按照如下两种标准分别实现二叉树的边界节点的逆时针打印。

标准一：

1，根节点为边界节点。

2，叶节点为边界节点。

3，如果节点在其所在的层中是最左的或最右的，那么该节点也是边界节点。

标准二：

1，根节点为边界节点。

2，叶节点为边界节点。

3，树左边界延伸下去的路径为边界节点。

4，树右边界延伸下去的路径为边界节点。

ps: 具体请对照样例

输入描述:

```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```

输出描述:

```
输出两行整数分别表示按两种标准的边界节点。
```

示例 1:

<img src="https://gitee.com/veal98/images/raw/master/img/20210418153718.png" style="zoom:80%;" />

```
输入
16 1
1 2 3
2 0 4
4 7 8
7 0 0
8 0 11
11 13 14
13 0 0
14 0 0
3 5 6
5 9 10
10 0 0
9 12 0
12 15 16
15 0 0
16 0 0
6 0 0

输出
1 2 4 7 11 13 14 15 16 12 10 6 3
1 2 4 7 13 14 15 16 10 6 3
```

【解题思路】：

对于标准一：

![](https://gitee.com/veal98/images/raw/master/img/20210418154232.png)

对于标准二：

![](https://gitee.com/veal98/images/raw/master/img/20210418154416.png)

【具体代码】：

```java

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        sc.nextLine(); // 第一行不重要
        TreeNode root = createTree(sc);

        List<Integer> edge1 = printEdge1(root);
        for (int i : edge1) {
            System.out.print(i + " ");
        }

        System.out.println();

        List<TreeNode> edge2 = new ArrayList<>();
        printEdge2(root, edge2);
        for (TreeNode node : edge2) {
            System.out.print(node.val + " ");
        }
    }

    // 按照标准一输出边界
    private static List<Integer> printEdge1(TreeNode root) {
        List<Integer> res = new ArrayList<>(); // 存储结果
        if (root == null) {
            return res;
        }

        int height = getHeight(root); // 获取二叉树高度
        // 存储每层的最左和最右节点
        // edgeMap[i][0] 表示第 i 层的最左节点
        // edgeMap[i][1] 表示第 i 层的最右节点
        TreeNode[][] edgeMap = new TreeNode[height][2];
        setEdgeMap(root, 0, edgeMap);

        // 打印左边界
        for (int i = 0; i < edgeMap.length; i ++) {
            res.add(edgeMap[i][0].val);
        }

        // 打印既不是左边界也不是右边界的叶子节点
        List<TreeNode> leafNotInMapList = new ArrayList<>();
        getLeafNotInMap(root, 0, edgeMap, leafNotInMapList);
        for (TreeNode node : leafNotInMapList) {
            res.add(node.val);
        }

        // 打印右边界(自下向上),但不是左边界的节点
        for (int i = edgeMap.length-1; i >= 0; i --) {
            if (edgeMap[i][0] != edgeMap[i][1]) {
                res.add(edgeMap[i][1].val);
            }
        }

        return res;
    }

    // 递归获取二叉树高度
    private static int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {
            return 1;
        }

        int leftHeight = getHeight(root.left);
        int rightHeight = getHeight(root.right);

        return Math.max(leftHeight, rightHeight) + 1;
    }

    /**
     * 递归存储每层的最左和最右节点
     * @param root
     * @param h 第几层
     * @param edgeMap
     */
    private static void setEdgeMap(TreeNode root, int h, TreeNode[][] edgeMap) {
        if (root == null) {
            return ;
        }

        edgeMap[h][0] = (edgeMap[h][0] == null) ? root : edgeMap[h][0];
        edgeMap[h][1] = root;

        setEdgeMap(root.left, h + 1, edgeMap);
        setEdgeMap(root.right, h + 1, edgeMap);
    }

    // 获取既不是左边界也不是右边界的叶子节点
    private static void getLeafNotInMap(TreeNode root, int h, TreeNode[][] edgeMap, List<TreeNode> leafNotInMapList) {
        if (root == null) {
            return ;
        }

        if (root.left == null && root.right == null &&
            root != edgeMap[h][0] && root != edgeMap[h][1]) {
            leafNotInMapList.add(root);
        }

        getLeafNotInMap(root.left, h + 1, edgeMap, leafNotInMapList);
        getLeafNotInMap(root.right, h + 1, edgeMap, leafNotInMapList);

    }


    // 按照标准二输出边界
    private static void printEdge2(TreeNode root, List<TreeNode> edgeList) {
        if (root == null) {
            return ;
        }

        edgeList.add(root); // 头节点符合标准二的要求

        if (root.left != null && root.right != null) {
            // 打印左边界的延伸路径，以及 root 左子树上所有的叶节点
            List<TreeNode> leftEdgeList = new ArrayList<>();
            getLeftEdge(root.left, true, leftEdgeList);
            for (TreeNode node : leftEdgeList) {
                edgeList.add(node);
            }
            // 打印右边界的延伸路径，以及 root 右子树上所有的叶节点
            List<TreeNode> rightEdgeList = new ArrayList<>();
            getRightEdge(root.right, true, rightEdgeList);
            for (TreeNode node : rightEdgeList) {
                edgeList.add(node);
            }
        }
        else {
            printEdge2((root.left != null) ? root.left : root.right, edgeList);
        }
    }

    private static void getLeftEdge(TreeNode root, boolean print, List<TreeNode> leftEdgeList) {
        if (root == null) {
            return ;
        }

        // 叶子节点
        if (print == true || (root.left == null && root.right == null)) {
            leftEdgeList.add(root);
        }

        getLeftEdge(root.left, print, leftEdgeList);
        getLeftEdge(root.right, (print == true && root.left == null) ? true : false, leftEdgeList);
    }

    private static void getRightEdge(TreeNode root, boolean print, List<TreeNode> rightEdgeList) {
        if (root == null) {
            return ;
        }

        getRightEdge(root.left, (print == true && root.right == null) ? true : false, rightEdgeList);
        getRightEdge(root.right, print, rightEdgeList);

        // 叶子节点
        if (print || (root.left == null && root.right == null)) {
            rightEdgeList.add(root);
        }
    }

    // 构造二叉树
    private static TreeNode createTree(Scanner sc) {
        String[] values = sc.nextLine().split(" ");
        if (values.length < 3) {
            return null;
        }

        int value = Integer.parseInt(values[0]);
        int left = Integer.parseInt(values[1]);
        int right = Integer.parseInt(values[2]);

        TreeNode root = new TreeNode(value);
        if (left != 0) {
            root.left = createTree(sc);
        }
        if (right != 0) {
            root.right = createTree(sc);
        }

        return root;
    }

    // 定义二叉树
    static class TreeNode {
        private int val;
        private TreeNode left;
        private TreeNode right;

        public TreeNode (int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }
}
```

