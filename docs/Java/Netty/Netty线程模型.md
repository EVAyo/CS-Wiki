# 👍 Netty 高性能设计

---

Netty 作为异步事件驱动的网络，高性能之处主要来自于其 I/O 模型和线程处理模型

- **I/O 模型**：决定如何<u>**收发**</u>数据
- **线程模型**：决定如何<u>**处理**</u>数据

## 1. I/O 模型

用什么样的通道将数据发送给对方，BIO、NIO 或者 AIO，I/O 模型在很大程度上决定了框架的性能

### ① 阻塞 I/O

传统阻塞型 I/O(BIO) 可以用下图表示：

<img src="https://gitee.com/veal98/images/raw/master/img/20201210154406.png" style="zoom: 67%;" />

**特点**

- 每个请求都需要独立的线程完成 数据 read、业务处理、数据 write 的完整操作

**问题**

- 当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大
- 连接建立后，<u>如果当前线程暂时没有数据可读，则线程就阻塞在 read 操作上，造成线程资源浪费</u>

### ② I/O 复用模型

<img src="https://gitee.com/veal98/images/raw/master/img/20201210154503.png" style="zoom: 67%;" />

在 I/O 复用模型中，会用到 select，这个函数也会使进程阻塞，但是和阻塞 I/O 所不同的的，这两个函数可以同时阻塞多个 I/O 操作，而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数

**Netty 的非阻塞 I/O 的实现关键是基于 I/O 复用模型**，这里用 Selector 对象表示：

<img src="https://gitee.com/veal98/images/raw/master/img/20201210154807.png" style="zoom:67%;" />

**Netty 的 IO 线程 `NioEventLoop` 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个客户端连接**。当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。

由于**读写操作都是非阻塞的**，这就可以充分提升 IO 线程的运行效率，避免由于频繁 I/O 阻塞导致的线程挂起，一个 I/O 线程可以并发处理N个客户端连接和读写操作，这**从根本上解决了传统同步阻塞 I/O一个连接一个线程的模型**，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。

### ③ 基于 Buffer

传统的 I/O 是面向字节流或字符流的，以流式的方式顺序地从一个 Stream 中读取一个或多个字节, 因此也就不能随意改变读取指针的位置。

在 NIO 中, 抛弃了传统的 I/O 流, 而是引入了 `Channel `和 `Buffer` 的概念. 在 NIO 中, 只能从 `Channel` 中读取数据到 `Buffer` 中或将数据从 `Buffer` 中写入到 `Channel`。

基于 buffer 的操作不像传统 IO 的顺序操作, NIO 中可以随意地读取任意位置的数据

## 2. Reactor 线程模型

