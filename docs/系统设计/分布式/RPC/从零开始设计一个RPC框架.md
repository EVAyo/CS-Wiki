# 🏆 从零开始设计一个 RPC 框架

---

## 🍉 实现一个最基本的 RPC 框架需要哪些东西

RPC 框架领域的集大成者 **Dubbo** 的架构如下图所示：

<img src="https://gitee.com/veal98/images/raw/master/img/20201216210433.png" style="zoom:80%;" />

🔸 节点说明：

| 节点         | 角色说明                               |
| ------------ | -------------------------------------- |
| `Deployer`   | 自动部署服务的本地代理                 |
| `Repository` | 仓库用于存储服务应用发布包             |
| `Scheduler`  | 调度中心基于访问压力自动增减服务提供者 |
| `Admin`      | 统一管理控制台                         |
| `Registry`   | 服务注册与发现的注册中心               |
| `Monitor`    | 统计服务的调用次数和调用时间的监控中心 |

🔸 调用关系说明：

1. 服务容器负责启动，加载，运行服务提供者。
2. **服务提供者在启动时，向注册中心注册自己提供的服务**。
3. **服务消费者在启动时，向注册中心订阅自己所需的服务**。
4. 注册中心返回**服务提供者地址列表**给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5. 服务消费者 从提供者地址列表中 基于软负载均衡算法 选一台提供者进行调用，如果调用失败，再选另一台调用。
6. **服务消费者和提供者**，在内存中累计调用次数和调用时间，**定时每分钟发送一次统计数据到监控中心**。

参考 Dubbo ，我们说一下设计一个最基本的 RPC 框架的思路或者说实现一个最基本的 RPC 框架需要哪些东西：

### ① 注册中心

**服务注册与发现的注册中心 Registry 负责服务地址的注册与查找，相当于目录服务。** 服务端启动的时候将服务名称及其对应的地址 (ip+port) 注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。

👍 推荐使用 **Zookeeper** 作为注册中心：

ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。并且，**ZooKeeper 将数据保存在内存中，性能是非常棒的**。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。

### ② 网络传输

**既然我们要调用远程的方法，那必然需要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端。**

网络传输具体实现可以使用 Socket 、NIO、Netty：

- **Socket**：Java 中最原始、最基础的网络通信方式。但是Socket 是阻塞 IO、性能低并且功能单一
- **NIO**：同步非阻塞的 I/O 模型，但是用它来进行网络编程真的太麻烦了
- **Netty**：基于 NIO 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程, 并且性能以及安全性等很多方面甚至都要更好。支持多种协议如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。

👍 推荐使用 **Netty**

### ③ 序列化和反序列化

要在网络传输数据就必然涉及到**序列化和反序列化**

因为网络传输的数据必须是二进制的。因此，我们的 Java 对象没办法直接在网络中传输。为了能够让 Java 对象在网络中传输我们需要将其**序列化**为二进制的数据。我们最终需要的还是目标 Java 对象，因此我们还要将二进制的数据 “解析” 为目标 Java 对象，也就是对二进制数据再进行一次**反序列化**。

另外，不仅网络传输的时候需要用到序列化和反序列化，将对象存储到文件、数据库等场景都需要用到序列化和反序列化。

![](https://gitee.com/veal98/images/raw/master/img/20201216211648.png)

JDK 自带的序列化，只需实现 `java.io.Serializable`接口即可，不过这种方式不推荐，因为不支持跨语言调用并且性能比较差。

比较常见的序列化框架：Kryo、hessian、protostuff 等

👍 推荐 Kryo

### ④ 动态代理

我们知道代理模式就是： 我们给某一个对象提供一个代理对象，并由代理对象来代替真实对象做一些事情。你可以把代理对象理解为一个幕后的工具人。 举个例子：我们真实对象调用方法的时候，我们可以通过代理对象去做一些事情比如安全校验、日志打印等等。但是，这个过程是完全对真实对象屏蔽的。

讲完了代理模式，再来说动态代理在 RPC 框架中的作用。

RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，我们不需要关心远程方法调用的细节比如网络传输。

**怎样才能屏蔽程方法调用的底层细节呢？答案就是动态代理**：简单来说，当你调用远程方法的时候，实际是通过代理对象来传输网络请求，因为我们是无法直接调用远程方法的。

动态代理机制包括 JDK 动态代理、CGLIB 动态代理、Javassist 动态代理等

### ⑤ 负载均衡

当我们的系统中的某个服务的访问量特别大的时候，假设我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。

**负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题**。

### ⑥ 传输/通信协议

我们还需要设计一个私有的 RPC 协议（通信/传输协议），这个协议是客户端（服务消费方）和服务端（服务提供方）交流的基础。

简单来说：**通过设计传输协议，我们定义需要传输哪些类型的数据， 并且还会规定每一种类型的数据应该占多少字节。这样我们在接收到二级制数据之后，就可以正确的解析出我们需要的数据。**

通常一些标准的 RPC 协议包含下面这些内容：

- **魔数** ： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。
- **序列化器编号** ：标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化方式。
- **消息体长度** ： 运行时计算出来。
- ..........

## 🔮 需要的技术储备

本项目基于 Netty + Kryo + Zookeeper 实现，学习本项目，你需要下面这些技术储备：

- 🔸 **Java 基础**

  相关教程见 [CS Wiki - Java 基础](https://veal98.gitee.io/cs-wiki/#/README?id=java-%e5%9f%ba%e7%a1%80)

  - 动态代理机制
  - Java I/O 系统
  - 序列化机制以及序列化框架（Kryo ......）的基本使用
  - Java 网络编程（Socket 编程）
  - Java 并发/多线程
  - ..........

- 🔸 **Netty 4.x**

  相关教程见 [CS Wiki - Netty 4.x](https://veal98.gitee.io/cs-wiki/#/README?id=%e2%91%a2-netty-4x)

- 🔸 **Zookeeper**

  相关教程见 [CS Wiki - 分布式协调服务 Zookeeper](https://veal98.gitee.io/cs-wiki/#/README?id=%e2%91%a4-%e5%88%86%e5%b8%83%e5%bc%8f%e5%8d%8f%e8%b0%83%e6%9c%8d%e5%8a%a1-zookeeper)

## 📖 完整教程



